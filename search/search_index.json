{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Tabular SSL Documentation","text":"<p>Welcome to the official documentation for the Tabular SSL library. This documentation is organized following the Di\u00e1taxis framework to provide you with the most effective learning and reference experience.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#tutorials","title":"Tutorials","text":"<p>Learn how to use Tabular SSL through step-by-step guides. Start here if you're new to the library.</p> <ul> <li>Getting Started</li> <li>Basic Usage</li> </ul>"},{"location":"#how-to-guides","title":"How-to Guides","text":"<p>Find practical solutions to specific problems and tasks.</p> <ul> <li>Data Preparation</li> <li>Model Training</li> <li>Evaluation</li> </ul>"},{"location":"#reference","title":"Reference","text":"<p>Detailed technical documentation of the library's components.</p> <ul> <li>API Reference</li> <li>Models</li> <li>Data Utilities</li> <li>Utility Functions</li> </ul>"},{"location":"#explanation","title":"Explanation","text":"<p>Understand the concepts and design decisions behind Tabular SSL.</p> <ul> <li>Architecture Overview</li> <li>SSL Methods</li> <li>Performance Considerations</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from tabular_ssl import TabularSSL\n\n# Initialize the model\nmodel = TabularSSL()\n\n# Train the model\nmodel.train(data)\n\n# Make predictions\npredictions = model.predict(new_data)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tabular-ssl\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. </p>"},{"location":"explanation/","title":"Explanation","text":"<p>This section provides background information and explanations of the concepts and design decisions behind Tabular SSL.</p>"},{"location":"explanation/#available-topics","title":"Available Topics","text":"<ul> <li>Architecture Overview - System design and components</li> <li>SSL Methods - Self-supervised learning approaches</li> <li>Performance Considerations - Optimization and scaling</li> </ul>"},{"location":"explanation/#key-concepts","title":"Key Concepts","text":""},{"location":"explanation/#self-supervised-learning","title":"Self-Supervised Learning","text":"<p>Self-supervised learning (SSL) is a machine learning paradigm where models learn from unlabeled data by creating their own supervision signals. In the context of tabular data, this involves:</p> <ul> <li>Feature masking and reconstruction</li> <li>Contrastive learning</li> <li>Predictive tasks</li> </ul>"},{"location":"explanation/#architecture","title":"Architecture","text":"<p>The Tabular SSL architecture is designed to:</p> <ul> <li>Handle mixed data types (numerical and categorical)</li> <li>Process variable-length sequences</li> <li>Learn robust representations</li> <li>Scale to large datasets</li> </ul>"},{"location":"explanation/#performance","title":"Performance","text":"<p>Key performance considerations include:</p> <ul> <li>Memory efficiency</li> <li>Training speed</li> <li>Model complexity</li> <li>Inference latency</li> </ul>"},{"location":"explanation/#related-resources","title":"Related Resources","text":"<ul> <li>Tutorials - Step-by-step guides</li> <li>How-to Guides - Practical solutions</li> <li>Reference - Technical documentation </li> </ul>"},{"location":"explanation/architecture/","title":"Architecture Overview","text":"<p>This section explains the architecture and design decisions behind Tabular SSL.</p>"},{"location":"explanation/architecture/#system-design","title":"System Design","text":""},{"location":"explanation/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The Tabular SSL system consists of several key components:</p> <ol> <li>Data Processing Layer</li> <li>Data loading and validation</li> <li>Feature preprocessing</li> <li> <p>Data augmentation</p> </li> <li> <p>Model Layer</p> </li> <li>Feature embedding</li> <li>Encoder components (Transformer, RNN, LSTM, etc.)</li> <li> <p>Task-specific heads</p> </li> <li> <p>Training Layer</p> </li> <li>Self-supervised learning</li> <li>Optimization</li> <li> <p>Monitoring</p> </li> <li> <p>Evaluation Layer</p> </li> <li>Metrics computation</li> <li>Model interpretation</li> <li>Performance analysis</li> </ol>"},{"location":"explanation/architecture/#component-details","title":"Component Details","text":""},{"location":"explanation/architecture/#data-processing","title":"Data Processing","text":""},{"location":"explanation/architecture/#feature-embedding","title":"Feature Embedding","text":"<ul> <li>Handles mixed data types (numerical and categorical)</li> <li>Learns feature representations</li> <li>Supports variable-length sequences</li> </ul>"},{"location":"explanation/architecture/#data-augmentation","title":"Data Augmentation","text":"<ul> <li>Feature masking</li> <li>Noise injection</li> <li>Synthetic sample generation</li> </ul>"},{"location":"explanation/architecture/#model-architecture","title":"Model Architecture","text":""},{"location":"explanation/architecture/#encoder-components","title":"Encoder Components","text":"<p>The system supports multiple encoder types through Hydra's configuration system:</p> <ol> <li>Transformer Encoder</li> <li>Multi-head self-attention</li> <li>Feed-forward networks</li> <li>Layer normalization</li> <li> <p>Residual connections</p> </li> <li> <p>RNN-based Encoders</p> </li> <li>RNN, LSTM, and GRU variants</li> <li>Bidirectional processing</li> <li> <p>Variable sequence lengths</p> </li> <li> <p>State Space Models</p> </li> <li>SSM and S4 implementations</li> <li>Efficient sequence modeling</li> <li>Long-range dependencies</li> </ol>"},{"location":"explanation/architecture/#task-heads","title":"Task Heads","text":"<ul> <li>Feature reconstruction</li> <li>Contrastive learning</li> <li>Predictive tasks</li> </ul>"},{"location":"explanation/architecture/#configuration-system","title":"Configuration System","text":"<p>The system uses Hydra's configuration system with the <code>_target_</code> pattern for flexible component instantiation:</p> <pre><code># Example configuration\n_target_: tabular_ssl.models.TabularSSL\n\nsequence_encoder:\n  _target_: tabular_ssl.models.encoders.TransformerEncoder\n  input_dim: 16\n  hidden_dim: 32\n  num_layers: 2\n  num_heads: 4\n</code></pre> <p>Benefits of this approach: 1. Type Safety: Hydra validates class existence and parameters 2. Flexibility: Easy to add new components without code changes 3. Composition: Components can be nested and composed 4. IDE Support: Better autocomplete and type checking</p>"},{"location":"explanation/architecture/#training-system","title":"Training System","text":""},{"location":"explanation/architecture/#self-supervised-learning","title":"Self-Supervised Learning","text":"<ul> <li>Masked feature prediction</li> <li>Contrastive learning</li> <li>Feature reconstruction</li> </ul>"},{"location":"explanation/architecture/#optimization","title":"Optimization","text":"<ul> <li>Adam optimizer</li> <li>Learning rate scheduling</li> <li>Gradient clipping</li> </ul>"},{"location":"explanation/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"explanation/architecture/#why-hydra-configuration","title":"Why Hydra Configuration?","text":"<p>The system uses Hydra's configuration system for several reasons:</p> <ol> <li>Flexibility</li> <li>Easy to add new components</li> <li>Runtime configuration changes</li> <li> <p>Experiment management</p> </li> <li> <p>Type Safety</p> </li> <li>Parameter validation</li> <li>Class existence checking</li> <li> <p>Better error messages</p> </li> <li> <p>Composition</p> </li> <li>Nested configurations</li> <li>Component reuse</li> <li>Modular design</li> </ol>"},{"location":"explanation/architecture/#why-self-supervised-learning","title":"Why Self-Supervised Learning?","text":"<p>Self-supervised learning offers several advantages:</p> <ol> <li>Data Efficiency</li> <li>Learn from unlabeled data</li> <li>Reduce annotation costs</li> <li> <p>Better generalization</p> </li> <li> <p>Representation Learning</p> </li> <li>Learn robust features</li> <li>Capture data structure</li> <li> <p>Transfer knowledge</p> </li> <li> <p>Flexibility</p> </li> <li>Multiple learning tasks</li> <li>Adapt to data types</li> <li>Custom objectives</li> </ol>"},{"location":"explanation/architecture/#implementation-details","title":"Implementation Details","text":""},{"location":"explanation/architecture/#code-organization","title":"Code Organization","text":"<pre><code>tabular_ssl/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 encoders/\n\u2502   \u2502   \u251c\u2500\u2500 transformer.py\n\u2502   \u2502   \u251c\u2500\u2500 rnn.py\n\u2502   \u2502   \u251c\u2500\u2500 lstm.py\n\u2502   \u2502   \u251c\u2500\u2500 gru.py\n\u2502   \u2502   \u251c\u2500\u2500 ssm.py\n\u2502   \u2502   \u2514\u2500\u2500 s4.py\n\u2502   \u251c\u2500\u2500 embeddings/\n\u2502   \u2502   \u2514\u2500\u2500 feature_embedding.py\n\u2502   \u251c\u2500\u2500 heads/\n\u2502   \u2502   \u251c\u2500\u2500 projection.py\n\u2502   \u2502   \u2514\u2500\u2500 prediction.py\n\u2502   \u2514\u2500\u2500 base.py\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 loader.py\n\u2502   \u251c\u2500\u2500 transformers.py\n\u2502   \u2514\u2500\u2500 augmentation.py\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 evaluation.py\n\u2502   \u251c\u2500\u2500 visualization.py\n\u2502   \u2514\u2500\u2500 training.py\n\u2514\u2500\u2500 examples/\n    \u251c\u2500\u2500 basic_usage.py\n    \u2514\u2500\u2500 advanced_usage.py\n</code></pre>"},{"location":"explanation/architecture/#key-classes","title":"Key Classes","text":""},{"location":"explanation/architecture/#tabularssl","title":"TabularSSL","text":"<ul> <li>Main model class</li> <li>Handles training and inference</li> <li>Uses Hydra for component instantiation</li> </ul>"},{"location":"explanation/architecture/#dataloader","title":"DataLoader","text":"<ul> <li>Data loading and preprocessing</li> <li>Feature engineering</li> <li>Data validation</li> </ul>"},{"location":"explanation/architecture/#trainingmanager","title":"TrainingManager","text":"<ul> <li>Training loop</li> <li>Optimization</li> <li>Monitoring</li> </ul>"},{"location":"explanation/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"explanation/architecture/#memory-efficiency","title":"Memory Efficiency","text":"<ol> <li>Batch Processing</li> <li>Dynamic batch sizes</li> <li>Gradient accumulation</li> <li> <p>Memory-efficient attention</p> </li> <li> <p>Model Optimization</p> </li> <li>Parameter sharing</li> <li>Quantization</li> <li>Pruning</li> </ol>"},{"location":"explanation/architecture/#training-speed","title":"Training Speed","text":"<ol> <li>Hardware Acceleration</li> <li>GPU support</li> <li>Mixed precision</li> <li> <p>Parallel processing</p> </li> <li> <p>Optimization</p> </li> <li>Efficient data loading</li> <li>Cached computations</li> <li>Optimized attention</li> </ol>"},{"location":"explanation/architecture/#related-resources","title":"Related Resources","text":"<ul> <li>SSL Methods - Self-supervised learning approaches</li> <li>Performance Considerations - Optimization and scaling</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"explanation/performance/","title":"Performance Considerations","text":"<p>This section covers performance optimization and scaling considerations for Tabular SSL.</p>"},{"location":"explanation/performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"explanation/performance/#batch-processing","title":"Batch Processing","text":"<ol> <li> <p>Dynamic Batch Sizes <pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    batch_size=32,  # Adjust based on available memory\n    gradient_accumulation_steps=4  # Accumulate gradients\n)\n</code></pre></p> </li> <li> <p>Memory-Efficient Attention <pre><code>model = TabularSSL(\n    input_dim=10,\n    attention_type='memory_efficient',  # Use memory-efficient attention\n    chunk_size=64  # Process attention in chunks\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#model-optimization","title":"Model Optimization","text":"<ol> <li> <p>Parameter Sharing <pre><code>model = TabularSSL(\n    input_dim=10,\n    share_parameters=True,  # Share parameters across layers\n    parameter_efficiency=True  # Use parameter-efficient methods\n)\n</code></pre></p> </li> <li> <p>Quantization <pre><code>from tabular_ssl.utils import quantize_model\n\n# Quantize model to reduce memory usage\nquantized_model = quantize_model(\n    model,\n    precision='int8'  # Use 8-bit quantization\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#training-speed","title":"Training Speed","text":""},{"location":"explanation/performance/#hardware-acceleration","title":"Hardware Acceleration","text":"<ol> <li> <p>GPU Support <pre><code>model = TabularSSL(\n    input_dim=10,\n    device='cuda',  # Use GPU\n    mixed_precision=True  # Enable mixed precision training\n)\n</code></pre></p> </li> <li> <p>Multi-GPU Training <pre><code>model = TabularSSL(\n    input_dim=10,\n    distributed=True,  # Enable distributed training\n    num_gpus=4  # Use 4 GPUs\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li> <p>Efficient Data Loading <pre><code>from tabular_ssl.data import DataLoader\n\nloader = DataLoader(\n    num_workers=4,  # Use multiple workers\n    pin_memory=True,  # Pin memory for faster transfer\n    prefetch_factor=2  # Prefetch data\n)\n</code></pre></p> </li> <li> <p>Cached Computations <pre><code>model = TabularSSL(\n    input_dim=10,\n    cache_attention=True,  # Cache attention computations\n    cache_size=1000  # Cache size\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"explanation/performance/#data-scaling","title":"Data Scaling","text":"<ol> <li> <p>Large Datasets <pre><code>from tabular_ssl.data import StreamingDataLoader\n\n# Use streaming data loader for large datasets\nloader = StreamingDataLoader(\n    data_path='large_dataset.csv',\n    batch_size=32,\n    chunk_size=10000  # Process data in chunks\n)\n</code></pre></p> </li> <li> <p>Distributed Data Processing <pre><code>from tabular_ssl.data import DistributedDataLoader\n\n# Use distributed data loader\nloader = DistributedDataLoader(\n    data_path='large_dataset.csv',\n    num_workers=4,\n    world_size=4  # Number of processes\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#model-scaling","title":"Model Scaling","text":"<ol> <li> <p>Model Parallelism <pre><code>model = TabularSSL(\n    input_dim=10,\n    model_parallel=True,  # Enable model parallelism\n    num_devices=4  # Split model across 4 devices\n)\n</code></pre></p> </li> <li> <p>Pipeline Parallelism <pre><code>model = TabularSSL(\n    input_dim=10,\n    pipeline_parallel=True,  # Enable pipeline parallelism\n    num_stages=4  # Number of pipeline stages\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"explanation/performance/#metrics","title":"Metrics","text":"<ol> <li> <p>Training Metrics <pre><code>from tabular_ssl.utils import TrainingMonitor\n\nmonitor = TrainingMonitor(\n    metrics=['loss', 'accuracy', 'memory_usage'],\n    log_interval=100\n)\n</code></pre></p> </li> <li> <p>System Metrics <pre><code>from tabular_ssl.utils import SystemMonitor\n\nmonitor = SystemMonitor(\n    metrics=['gpu_usage', 'memory_usage', 'throughput'],\n    log_interval=1\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#profiling","title":"Profiling","text":"<ol> <li> <p>Model Profiling <pre><code>from tabular_ssl.utils import profile_model\n\n# Profile model performance\nprofile = profile_model(\n    model,\n    input_size=(32, 10),  # Batch size, input dimension\n    num_runs=100\n)\n</code></pre></p> </li> <li> <p>Memory Profiling <pre><code>from tabular_ssl.utils import profile_memory\n\n# Profile memory usage\nmemory_profile = profile_memory(\n    model,\n    input_size=(32, 10)\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#best-practices","title":"Best Practices","text":""},{"location":"explanation/performance/#memory-management","title":"Memory Management","text":"<ol> <li>Batch Size Selection</li> <li>Start with small batch sizes</li> <li>Gradually increase if memory allows</li> <li> <p>Use gradient accumulation for large batches</p> </li> <li> <p>Model Architecture</p> </li> <li>Use parameter-efficient architectures</li> <li>Implement memory-efficient attention</li> <li>Consider model quantization</li> </ol>"},{"location":"explanation/performance/#training-optimization","title":"Training Optimization","text":"<ol> <li>Hardware Utilization</li> <li>Use GPU acceleration</li> <li>Enable mixed precision training</li> <li> <p>Implement distributed training</p> </li> <li> <p>Data Processing</p> </li> <li>Use efficient data loaders</li> <li>Implement data prefetching</li> <li>Cache frequent computations</li> </ol>"},{"location":"explanation/performance/#related-resources","title":"Related Resources","text":"<ul> <li>Architecture Overview - System design details</li> <li>SSL Methods - Learning approaches</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"explanation/ssl-methods/","title":"Self-Supervised Learning Methods","text":"<p>This section explains the self-supervised learning methods implemented in Tabular SSL.</p>"},{"location":"explanation/ssl-methods/#overview","title":"Overview","text":"<p>Self-supervised learning (SSL) is a machine learning paradigm where models learn from unlabeled data by creating their own supervision signals. In Tabular SSL, we implement several SSL methods:</p> <ol> <li>Masked Feature Prediction</li> <li>Contrastive Learning</li> <li>Feature Reconstruction</li> </ol>"},{"location":"explanation/ssl-methods/#masked-feature-prediction","title":"Masked Feature Prediction","text":""},{"location":"explanation/ssl-methods/#how-it-works","title":"How It Works","text":"<ol> <li>Feature Masking</li> <li>Randomly mask a portion of features</li> <li>Use a masking ratio (default: 0.15)</li> <li> <p>Preserve feature relationships</p> </li> <li> <p>Prediction Task</p> </li> <li>Predict masked features</li> <li>Use surrounding features as context</li> <li>Learn feature dependencies</li> </ol>"},{"location":"explanation/ssl-methods/#implementation","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    mask_ratio=0.15  # 15% of features masked\n)\n\n# Train with masked feature prediction\nhistory = model.train(\n    data=train_data,\n    ssl_method='masked_prediction'\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#contrastive-learning","title":"Contrastive Learning","text":""},{"location":"explanation/ssl-methods/#how-it-works_1","title":"How It Works","text":"<ol> <li>Data Augmentation</li> <li>Create positive pairs</li> <li>Apply transformations</li> <li> <p>Generate negative samples</p> </li> <li> <p>Contrastive Loss</p> </li> <li>Maximize similarity of positive pairs</li> <li>Minimize similarity of negative pairs</li> <li>Learn robust representations</li> </ol>"},{"location":"explanation/ssl-methods/#implementation_1","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_method='contrastive'\n)\n\n# Train with contrastive learning\nhistory = model.train(\n    data=train_data,\n    temperature=0.07,  # Temperature parameter\n    queue_size=65536   # Size of memory queue\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#feature-reconstruction","title":"Feature Reconstruction","text":""},{"location":"explanation/ssl-methods/#how-it-works_2","title":"How It Works","text":"<ol> <li>Autoencoder Architecture</li> <li>Encode input features</li> <li>Decode to reconstruct</li> <li> <p>Learn feature representations</p> </li> <li> <p>Reconstruction Loss</p> </li> <li>Minimize reconstruction error</li> <li>Learn feature relationships</li> <li>Capture data structure</li> </ol>"},{"location":"explanation/ssl-methods/#implementation_2","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_method='reconstruction'\n)\n\n# Train with feature reconstruction\nhistory = model.train(\n    data=train_data,\n    reconstruction_weight=1.0\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#combining-methods","title":"Combining Methods","text":""},{"location":"explanation/ssl-methods/#multi-task-learning","title":"Multi-Task Learning","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_methods=['masked_prediction', 'contrastive']\n)\n\n# Train with multiple SSL methods\nhistory = model.train(\n    data=train_data,\n    method_weights={\n        'masked_prediction': 0.5,\n        'contrastive': 0.5\n    }\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#method-selection","title":"Method Selection","text":""},{"location":"explanation/ssl-methods/#when-to-use-each-method","title":"When to Use Each Method","text":"<ol> <li>Masked Feature Prediction</li> <li>When feature relationships are important</li> <li>For structured tabular data</li> <li> <p>When interpretability is needed</p> </li> <li> <p>Contrastive Learning</p> </li> <li>For robust representations</li> <li>When data augmentation is possible</li> <li> <p>For transfer learning</p> </li> <li> <p>Feature Reconstruction</p> </li> <li>For simple feature learning</li> <li>When computational efficiency is important</li> <li>For basic representation learning</li> </ol>"},{"location":"explanation/ssl-methods/#best-practices","title":"Best Practices","text":""},{"location":"explanation/ssl-methods/#method-selection_1","title":"Method Selection","text":"<ol> <li>Data Characteristics</li> <li>Consider data structure</li> <li>Evaluate feature relationships</li> <li> <p>Assess data quality</p> </li> <li> <p>Task Requirements</p> </li> <li>Define learning objectives</li> <li>Consider downstream tasks</li> <li> <p>Evaluate computational needs</p> </li> <li> <p>Resource Constraints</p> </li> <li>Consider memory usage</li> <li>Evaluate training time</li> <li>Assess hardware requirements</li> </ol>"},{"location":"explanation/ssl-methods/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Hyperparameter Tuning</li> <li>Masking ratio</li> <li>Temperature parameter</li> <li> <p>Loss weights</p> </li> <li> <p>Training Strategy</p> </li> <li>Learning rate scheduling</li> <li>Batch size selection</li> <li> <p>Early stopping</p> </li> <li> <p>Evaluation</p> </li> <li>Monitor SSL metrics</li> <li>Evaluate downstream performance</li> <li>Compare methods</li> </ol>"},{"location":"explanation/ssl-methods/#related-resources","title":"Related Resources","text":"<ul> <li>Architecture Overview - System design details</li> <li>Performance Considerations - Optimization guide</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"how-to-guides/","title":"How-to Guides","text":"<p>This section contains practical guides for common tasks and specific use cases with Tabular SSL.</p>"},{"location":"how-to-guides/#available-guides","title":"Available Guides","text":"<ul> <li>Data Preparation - Learn how to prepare your data for Tabular SSL</li> <li>Model Training - Best practices for training models</li> <li>Evaluation - How to evaluate and interpret model results</li> </ul>"},{"location":"how-to-guides/#common-tasks","title":"Common Tasks","text":""},{"location":"how-to-guides/#data-preparation","title":"Data Preparation","text":"<ul> <li>Loading and preprocessing data</li> <li>Handling categorical variables</li> <li>Feature scaling and normalization</li> <li>Dealing with missing values</li> </ul>"},{"location":"how-to-guides/#model-training","title":"Model Training","text":"<ul> <li>Setting up training configurations</li> <li>Monitoring training progress</li> <li>Saving and loading models</li> <li>Hyperparameter tuning</li> </ul>"},{"location":"how-to-guides/#evaluation","title":"Evaluation","text":"<ul> <li>Computing performance metrics</li> <li>Visualizing results</li> <li>Model interpretation</li> <li>Error analysis</li> </ul>"},{"location":"how-to-guides/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>Tutorials - Step-by-step learning guides</li> <li>Explanation - Background information </li> </ul>"},{"location":"how-to-guides/data-preparation/","title":"Data Preparation Guide","text":"<p>This guide covers best practices for preparing your data for use with Tabular SSL.</p>"},{"location":"how-to-guides/data-preparation/#loading-data","title":"Loading Data","text":""},{"location":"how-to-guides/data-preparation/#from-csv-files","title":"From CSV Files","text":"<pre><code>from tabular_ssl.data import DataLoader\n\n# Initialize the data loader\ndata_loader = DataLoader()\n\n# Load data from CSV\ndata = data_loader.load_data('path/to/your/data.csv')\n</code></pre>"},{"location":"how-to-guides/data-preparation/#from-pandas-dataframe","title":"From Pandas DataFrame","text":"<pre><code>import pandas as pd\n\n# Create or load your DataFrame\ndf = pd.DataFrame({\n    'numeric_col': [1, 2, 3],\n    'categorical_col': ['A', 'B', 'A']\n})\n\n# Use the data loader\ndata_loader = DataLoader()\nprocessed_data = data_loader.preprocess(df)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#handling-different-data-types","title":"Handling Different Data Types","text":""},{"location":"how-to-guides/data-preparation/#categorical-variables","title":"Categorical Variables","text":"<pre><code># Specify categorical columns\ncategorical_cols = ['category1', 'category2']\nprocessed_data = data_loader.preprocess(\n    data,\n    categorical_cols=categorical_cols\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#numerical-variables","title":"Numerical Variables","text":"<pre><code># Numerical columns are automatically detected\n# You can specify scaling options\nprocessed_data = data_loader.preprocess(\n    data,\n    scale_numerical=True,  # Enable scaling\n    scaler='standard'      # Use standard scaler\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#dealing-with-missing-values","title":"Dealing with Missing Values","text":""},{"location":"how-to-guides/data-preparation/#automatic-handling","title":"Automatic Handling","text":"<pre><code># The data loader automatically handles missing values\nprocessed_data = data_loader.preprocess(\n    data,\n    handle_missing=True,  # Enable missing value handling\n    missing_strategy='mean'  # Use mean imputation\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#manual-handling","title":"Manual Handling","text":"<pre><code>import pandas as pd\nimport numpy as np\n\n# Fill missing values\ndata = data.fillna({\n    'numeric_col': data['numeric_col'].mean(),\n    'categorical_col': data['categorical_col'].mode()[0]\n})\n</code></pre>"},{"location":"how-to-guides/data-preparation/#feature-engineering","title":"Feature Engineering","text":""},{"location":"how-to-guides/data-preparation/#creating-new-features","title":"Creating New Features","text":"<pre><code># Add interaction terms\ndata['interaction'] = data['feature1'] * data['feature2']\n\n# Add polynomial features\ndata['feature1_squared'] = data['feature1'] ** 2\n</code></pre>"},{"location":"how-to-guides/data-preparation/#feature-selection","title":"Feature Selection","text":"<pre><code>from tabular_ssl.utils import select_features\n\n# Select features based on importance\nselected_features = select_features(\n    data,\n    target_col='target',\n    method='importance',\n    threshold=0.01\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#data-validation","title":"Data Validation","text":""},{"location":"how-to-guides/data-preparation/#checking-data-quality","title":"Checking Data Quality","text":"<pre><code>from tabular_ssl.utils import validate_data\n\n# Validate data before processing\nvalidation_results = validate_data(data)\nprint(validation_results)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<ol> <li> <p>Inconsistent Data Types <pre><code># Convert columns to correct types\ndata['numeric_col'] = pd.to_numeric(data['numeric_col'])\ndata['categorical_col'] = data['categorical_col'].astype('category')\n</code></pre></p> </li> <li> <p>Outliers <pre><code># Remove outliers\ndata = data[data['numeric_col'].between(\n    data['numeric_col'].quantile(0.01),\n    data['numeric_col'].quantile(0.99)\n)]\n</code></pre></p> </li> </ol>"},{"location":"how-to-guides/data-preparation/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate your data before processing</li> <li>Handle missing values appropriately for your use case</li> <li>Scale numerical features when necessary</li> <li>Encode categorical variables properly</li> <li>Check for and handle outliers</li> <li>Document your preprocessing steps</li> </ol>"},{"location":"how-to-guides/data-preparation/#related-resources","title":"Related Resources","text":"<ul> <li>Model Training - Next steps after data preparation</li> <li>API Reference - Detailed API documentation</li> <li>Tutorials - Step-by-step guides </li> </ul>"},{"location":"how-to-guides/evaluation/","title":"Model Evaluation Guide","text":"<p>This guide covers how to evaluate and interpret your Tabular SSL models.</p>"},{"location":"how-to-guides/evaluation/#basic-evaluation","title":"Basic Evaluation","text":""},{"location":"how-to-guides/evaluation/#computing-metrics","title":"Computing Metrics","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\n# Evaluate model performance\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\nprint(metrics)\n</code></pre>"},{"location":"how-to-guides/evaluation/#cross-validation","title":"Cross-Validation","text":"<pre><code>from tabular_ssl.utils import cross_validate\n\n# Perform k-fold cross-validation\ncv_results = cross_validate(\n    model,\n    data,\n    n_splits=5,\n    metrics=['accuracy', 'f1']\n)\nprint(cv_results)\n</code></pre>"},{"location":"how-to-guides/evaluation/#advanced-evaluation","title":"Advanced Evaluation","text":""},{"location":"how-to-guides/evaluation/#custom-metrics","title":"Custom Metrics","text":"<pre><code>from tabular_ssl.utils import CustomMetric\n\n# Define custom metric\ndef custom_metric(y_true, y_pred):\n    # Your custom metric implementation\n    return score\n\n# Evaluate with custom metric\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', CustomMetric(custom_metric)]\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#model-comparison","title":"Model Comparison","text":"<pre><code>from tabular_ssl.utils import compare_models\n\n# Compare multiple models\ncomparison = compare_models(\n    models=[model1, model2, model3],\n    test_data=test_data,\n    metrics=['accuracy', 'f1']\n)\nprint(comparison)\n</code></pre>"},{"location":"how-to-guides/evaluation/#visualization","title":"Visualization","text":""},{"location":"how-to-guides/evaluation/#training-history","title":"Training History","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\n# Plot training metrics\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#performance-plots","title":"Performance Plots","text":"<pre><code>from tabular_ssl.utils import plot_performance\n\n# Plot various performance metrics\nfig = plot_performance(\n    model,\n    test_data,\n    plot_types=['confusion_matrix', 'roc_curve', 'precision_recall']\n)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#model-interpretation","title":"Model Interpretation","text":""},{"location":"how-to-guides/evaluation/#feature-importance","title":"Feature Importance","text":"<pre><code>from tabular_ssl.utils import get_feature_importance\n\n# Get feature importance scores\nimportance = get_feature_importance(model, test_data)\nprint(importance)\n</code></pre>"},{"location":"how-to-guides/evaluation/#shap-values","title":"SHAP Values","text":"<pre><code>from tabular_ssl.utils import get_shap_values\n\n# Compute SHAP values\nshap_values = get_shap_values(model, test_data)\n\n# Plot SHAP summary\nplot_shap_summary(shap_values, test_data)\n</code></pre>"},{"location":"how-to-guides/evaluation/#error-analysis","title":"Error Analysis","text":""},{"location":"how-to-guides/evaluation/#error-distribution","title":"Error Distribution","text":"<pre><code>from tabular_ssl.utils import analyze_errors\n\n# Analyze prediction errors\nerror_analysis = analyze_errors(\n    model,\n    test_data,\n    analysis_types=['distribution', 'correlation']\n)\nprint(error_analysis)\n</code></pre>"},{"location":"how-to-guides/evaluation/#error-visualization","title":"Error Visualization","text":"<pre><code>from tabular_ssl.utils import plot_errors\n\n# Plot error analysis\nfig = plot_errors(\n    model,\n    test_data,\n    plot_types=['residuals', 'error_distribution']\n)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#best-practices","title":"Best Practices","text":"<ol> <li>Use multiple evaluation metrics</li> <li>Perform cross-validation for robust results</li> <li>Compare against baseline models</li> <li>Analyze error patterns</li> <li>Visualize results for better understanding</li> <li>Consider domain-specific metrics</li> <li>Document evaluation methodology</li> <li>Validate results with statistical tests</li> </ol>"},{"location":"how-to-guides/evaluation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"how-to-guides/evaluation/#unbalanced-data","title":"Unbalanced Data","text":"<pre><code>from tabular_ssl.utils import balanced_metrics\n\n# Use balanced metrics\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['balanced_accuracy', 'f1']\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#small-test-sets","title":"Small Test Sets","text":"<pre><code># Use bootstrapping for small test sets\nfrom tabular_ssl.utils import bootstrap_evaluation\n\nresults = bootstrap_evaluation(\n    model,\n    test_data,\n    n_bootstrap=1000,\n    metrics=['accuracy', 'f1']\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#related-resources","title":"Related Resources","text":"<ul> <li>Model Training - Training your model</li> <li>Data Preparation - Preparing your data</li> <li>API Reference - Detailed API documentation </li> </ul>"},{"location":"how-to-guides/model-training/","title":"Model Training Guide","text":"<p>This guide covers best practices for training models with Tabular SSL.</p>"},{"location":"how-to-guides/model-training/#basic-training","title":"Basic Training","text":""},{"location":"how-to-guides/model-training/#simple-training-loop","title":"Simple Training Loop","text":"<pre><code>from tabular_ssl import TabularSSL\n\n# Initialize model\nmodel = TabularSSL(input_dim=10)\n\n# Train model\nhistory = model.train(\n    data=train_data,\n    batch_size=32,\n    epochs=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#training-with-validation","title":"Training with Validation","text":"<pre><code># Split data into train and validation sets\nfrom sklearn.model_selection import train_test_split\n\ntrain_data, val_data = train_test_split(\n    data,\n    test_size=0.2,\n    random_state=42\n)\n\n# Train with validation\nhistory = model.train(\n    data=train_data,\n    validation_data=val_data,\n    batch_size=32,\n    epochs=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#advanced-training","title":"Advanced Training","text":""},{"location":"how-to-guides/model-training/#custom-training-configuration","title":"Custom Training Configuration","text":"<pre><code>history = model.train(\n    data=train_data,\n    batch_size=64,\n    epochs=200,\n    learning_rate=1e-4,\n    weight_decay=1e-5,\n    early_stopping=True,\n    patience=10,\n    min_delta=0.001\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#learning-rate-scheduling","title":"Learning Rate Scheduling","text":"<pre><code>from tabular_ssl.utils import get_lr_scheduler\n\n# Create learning rate scheduler\nlr_scheduler = get_lr_scheduler(\n    initial_lr=1e-3,\n    scheduler_type='cosine',\n    warmup_epochs=5\n)\n\n# Train with scheduler\nhistory = model.train(\n    data=train_data,\n    learning_rate=1e-3,\n    lr_scheduler=lr_scheduler\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#monitoring-training","title":"Monitoring Training","text":""},{"location":"how-to-guides/model-training/#logging-metrics","title":"Logging Metrics","text":"<pre><code>from tabular_ssl.utils import TrainingLogger\n\n# Initialize logger\nlogger = TrainingLogger(log_dir='logs')\n\n# Train with logging\nhistory = model.train(\n    data=train_data,\n    logger=logger,\n    log_interval=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#visualizing-progress","title":"Visualizing Progress","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\n# Plot training metrics\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/model-training/#model-checkpointing","title":"Model Checkpointing","text":""},{"location":"how-to-guides/model-training/#saving-checkpoints","title":"Saving Checkpoints","text":"<pre><code># Save model checkpoints\nhistory = model.train(\n    data=train_data,\n    save_dir='checkpoints',\n    save_best_only=True,\n    save_frequency=5\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#loading-checkpoints","title":"Loading Checkpoints","text":"<pre><code># Load best model\nmodel = TabularSSL.load('checkpoints/best_model.pt')\n\n# Load specific checkpoint\nmodel = TabularSSL.load('checkpoints/model_epoch_50.pt')\n</code></pre>"},{"location":"how-to-guides/model-training/#hyperparameter-tuning","title":"Hyperparameter Tuning","text":""},{"location":"how-to-guides/model-training/#grid-search","title":"Grid Search","text":"<pre><code>from tabular_ssl.utils import grid_search\n\n# Define parameter grid\nparam_grid = {\n    'hidden_dim': [128, 256, 512],\n    'num_layers': [2, 4, 6],\n    'dropout': [0.1, 0.2, 0.3]\n}\n\n# Perform grid search\nbest_params = grid_search(\n    model_class=TabularSSL,\n    param_grid=param_grid,\n    train_data=train_data,\n    val_data=val_data\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#random-search","title":"Random Search","text":"<pre><code>from tabular_ssl.utils import random_search\n\n# Define parameter distributions\nparam_distributions = {\n    'hidden_dim': [128, 256, 512],\n    'num_layers': [2, 4, 6],\n    'dropout': [0.1, 0.2, 0.3]\n}\n\n# Perform random search\nbest_params = random_search(\n    model_class=TabularSSL,\n    param_distributions=param_distributions,\n    train_data=train_data,\n    val_data=val_data,\n    n_iter=10\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#best-practices","title":"Best Practices","text":"<ol> <li>Always use validation data during training</li> <li>Implement early stopping to prevent overfitting</li> <li>Use learning rate scheduling for better convergence</li> <li>Monitor training metrics regularly</li> <li>Save model checkpoints</li> <li>Experiment with different hyperparameters</li> <li>Use appropriate batch sizes for your data</li> <li>Normalize your data before training</li> </ol>"},{"location":"how-to-guides/model-training/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"how-to-guides/model-training/#overfitting","title":"Overfitting","text":"<pre><code># Increase dropout\nmodel = TabularSSL(\n    input_dim=10,\n    dropout=0.3  # Increased from default\n)\n\n# Add regularization\nhistory = model.train(\n    data=train_data,\n    weight_decay=1e-4\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#underfitting","title":"Underfitting","text":"<pre><code># Increase model capacity\nmodel = TabularSSL(\n    input_dim=10,\n    hidden_dim=512,  # Increased from default\n    num_layers=6     # Increased from default\n)\n\n# Train for more epochs\nhistory = model.train(\n    data=train_data,\n    epochs=300  # Increased from default\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#related-resources","title":"Related Resources","text":"<ul> <li>Data Preparation - Preparing your data for training</li> <li>Evaluation - Evaluating your trained model</li> <li>API Reference - Detailed API documentation </li> </ul>"},{"location":"reference/","title":"Reference Documentation","text":"<p>This section provides detailed technical documentation for all components of the Tabular SSL library.</p>"},{"location":"reference/#available-references","title":"Available References","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Models - Model architectures and configurations</li> <li>Data Utilities - Data loading and preprocessing utilities</li> <li>Utility Functions - Helper functions and tools</li> </ul>"},{"location":"reference/#quick-reference","title":"Quick Reference","text":""},{"location":"reference/#main-classes","title":"Main Classes","text":"<pre><code>from tabular_ssl import TabularSSL\nfrom tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/#common-functions","title":"Common Functions","text":"<pre><code>from tabular_ssl.utils import evaluate_model, plot_training_history\n</code></pre>"},{"location":"reference/#module-structure","title":"Module Structure","text":"<ul> <li><code>tabular_ssl/</code> - Main package</li> <li><code>models/</code> - Model implementations</li> <li><code>data/</code> - Data handling utilities</li> <li><code>utils/</code> - Helper functions</li> </ul>"},{"location":"reference/#related-resources","title":"Related Resources","text":"<ul> <li>Tutorials - Step-by-step guides</li> <li>How-to Guides - Practical solutions</li> <li>Explanation - Background information </li> </ul>"},{"location":"reference/api/","title":"API Reference","text":"<p>This section provides detailed technical documentation for all public APIs in the Tabular SSL library.</p>"},{"location":"reference/api/#models","title":"Models","text":""},{"location":"reference/api/#tabularssl","title":"TabularSSL","text":"<p>The main class for self-supervised learning on tabular data.</p> <pre><code>from tabular_ssl import TabularSSL\n</code></pre>"},{"location":"reference/api/#parameters","title":"Parameters","text":"<ul> <li><code>input_dim</code> (int): Dimension of input features</li> <li><code>hidden_dim</code> (int, optional): Dimension of hidden layers. Defaults to 256.</li> <li><code>num_layers</code> (int, optional): Number of transformer layers. Defaults to 4.</li> <li><code>num_heads</code> (int, optional): Number of attention heads. Defaults to 4.</li> <li><code>dropout</code> (float, optional): Dropout rate. Defaults to 0.1.</li> <li><code>mask_ratio</code> (float, optional): Ratio of features to mask during training. Defaults to 0.15.</li> </ul>"},{"location":"reference/api/#methods","title":"Methods","text":""},{"location":"reference/api/#traindata-batch_size32-epochs100-learning_rate1e-4","title":"<code>train(data, batch_size=32, epochs=100, learning_rate=1e-4)</code>","text":"<p>Train the model using self-supervised learning.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>batch_size</code> (int): Batch size for training - <code>epochs</code> (int): Number of training epochs - <code>learning_rate</code> (float): Learning rate</p> <p>Returns: - <code>dict</code>: Training history</p>"},{"location":"reference/api/#predictdata","title":"<code>predict(data)</code>","text":"<p>Make predictions on new data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data</p> <p>Returns: - <code>np.ndarray</code>: Model predictions</p>"},{"location":"reference/api/#data-utilities","title":"Data Utilities","text":""},{"location":"reference/api/#dataloader","title":"DataLoader","text":"<p>Utility class for loading and preprocessing tabular data.</p> <pre><code>from tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/api/#methods_1","title":"Methods","text":""},{"location":"reference/api/#load_datafile_path-target_colnone","title":"<code>load_data(file_path, target_col=None)</code>","text":"<p>Load data from a file.</p> <p>Parameters: - <code>file_path</code> (str): Path to the data file - <code>target_col</code> (str, optional): Name of the target column</p> <p>Returns: - <code>pd.DataFrame</code>: Loaded data</p>"},{"location":"reference/api/#preprocessdata-categorical_colsnone","title":"<code>preprocess(data, categorical_cols=None)</code>","text":"<p>Preprocess the data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>categorical_cols</code> (list, optional): List of categorical column names</p> <p>Returns: - <code>pd.DataFrame</code>: Preprocessed data</p>"},{"location":"reference/api/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/api/#evaluation","title":"Evaluation","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n</code></pre>"},{"location":"reference/api/#evaluate_modelmodel-test_data-metricsaccuracy-f1","title":"<code>evaluate_model(model, test_data, metrics=['accuracy', 'f1'])</code>","text":"<p>Evaluate model performance.</p> <p>Parameters: - <code>model</code>: Trained model - <code>test_data</code> (pd.DataFrame): Test data - <code>metrics</code> (list): List of metrics to compute</p> <p>Returns: - <code>dict</code>: Dictionary of metric scores</p>"},{"location":"reference/api/#visualization","title":"Visualization","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n</code></pre>"},{"location":"reference/api/#plot_training_historyhistory","title":"<code>plot_training_history(history)</code>","text":"<p>Plot training history.</p> <p>Parameters: - <code>history</code> (dict): Training history dictionary</p> <p>Returns: - <code>matplotlib.figure.Figure</code>: Plot figure </p>"},{"location":"reference/data/","title":"Data Utilities Reference","text":"<p>This section provides detailed documentation of the data loading and preprocessing utilities in Tabular SSL.</p>"},{"location":"reference/data/#dataloader","title":"DataLoader","text":"<p>The main class for loading and preprocessing tabular data.</p> <pre><code>from tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/data/#methods","title":"Methods","text":""},{"location":"reference/data/#load_datafile_path-target_colnone","title":"<code>load_data(file_path, target_col=None)</code>","text":"<p>Load data from a file.</p> <p>Parameters: - <code>file_path</code> (str): Path to the data file - <code>target_col</code> (str, optional): Name of the target column</p> <p>Returns: - <code>pd.DataFrame</code>: Loaded data</p>"},{"location":"reference/data/#preprocessdata-categorical_colsnone-scale_numericaltrue-handle_missingtrue","title":"<code>preprocess(data, categorical_cols=None, scale_numerical=True, handle_missing=True)</code>","text":"<p>Preprocess the data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>categorical_cols</code> (list, optional): List of categorical column names - <code>scale_numerical</code> (bool, optional): Whether to scale numerical features - <code>handle_missing</code> (bool, optional): Whether to handle missing values</p> <p>Returns: - <code>pd.DataFrame</code>: Preprocessed data</p>"},{"location":"reference/data/#data-transformers","title":"Data Transformers","text":""},{"location":"reference/data/#categoricaltransformer","title":"CategoricalTransformer","text":"<pre><code>from tabular_ssl.data import CategoricalTransformer\n\ntransformer = CategoricalTransformer(\n    columns=['category1', 'category2'],\n    encoding='onehot'\n)\n</code></pre>"},{"location":"reference/data/#numericaltransformer","title":"NumericalTransformer","text":"<pre><code>from tabular_ssl.data import NumericalTransformer\n\ntransformer = NumericalTransformer(\n    columns=['numeric1', 'numeric2'],\n    scaling='standard'\n)\n</code></pre>"},{"location":"reference/data/#data-validation","title":"Data Validation","text":""},{"location":"reference/data/#datavalidator","title":"DataValidator","text":"<pre><code>from tabular_ssl.data import DataValidator\n\nvalidator = DataValidator(\n    required_columns=['col1', 'col2'],\n    data_types={\n        'col1': 'numeric',\n        'col2': 'categorical'\n    }\n)\n</code></pre>"},{"location":"reference/data/#data-splitting","title":"Data Splitting","text":""},{"location":"reference/data/#datasplitter","title":"DataSplitter","text":"<pre><code>from tabular_ssl.data import DataSplitter\n\nsplitter = DataSplitter(\n    test_size=0.2,\n    val_size=0.1,\n    random_state=42\n)\n</code></pre>"},{"location":"reference/data/#feature-engineering","title":"Feature Engineering","text":""},{"location":"reference/data/#featureengineer","title":"FeatureEngineer","text":"<pre><code>from tabular_ssl.data import FeatureEngineer\n\nengineer = FeatureEngineer(\n    interactions=True,\n    polynomials=True,\n    degree=2\n)\n</code></pre>"},{"location":"reference/data/#data-augmentation","title":"Data Augmentation","text":""},{"location":"reference/data/#dataaugmenter","title":"DataAugmenter","text":"<pre><code>from tabular_ssl.data import DataAugmenter\n\naugmenter = DataAugmenter(\n    noise_level=0.1,\n    mask_ratio=0.15\n)\n</code></pre>"},{"location":"reference/data/#common-operations","title":"Common Operations","text":""},{"location":"reference/data/#loading-data","title":"Loading Data","text":"<pre><code># Load from CSV\ndata = DataLoader().load_data('data.csv')\n\n# Load from DataFrame\ndata = DataLoader().load_data(df)\n</code></pre>"},{"location":"reference/data/#preprocessing","title":"Preprocessing","text":"<pre><code># Basic preprocessing\nprocessed_data = DataLoader().preprocess(\n    data,\n    categorical_cols=['category1', 'category2']\n)\n\n# Advanced preprocessing\nprocessed_data = DataLoader().preprocess(\n    data,\n    categorical_cols=['category1', 'category2'],\n    scale_numerical=True,\n    handle_missing=True,\n    missing_strategy='mean'\n)\n</code></pre>"},{"location":"reference/data/#data-splitting_1","title":"Data Splitting","text":"<pre><code># Split data\ntrain_data, val_data, test_data = DataSplitter().split(data)\n</code></pre>"},{"location":"reference/data/#feature-engineering_1","title":"Feature Engineering","text":"<pre><code># Create new features\nengineered_data = FeatureEngineer().transform(data)\n</code></pre>"},{"location":"reference/data/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate data before processing</li> <li>Handle missing values appropriately</li> <li>Scale numerical features</li> <li>Encode categorical variables</li> <li>Split data before preprocessing</li> <li>Document preprocessing steps</li> <li>Save preprocessed data</li> <li>Use appropriate data types</li> </ol>"},{"location":"reference/data/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>How-to Guides - Data preparation guides</li> <li>Tutorials - Getting started guides </li> </ul>"},{"location":"reference/models/","title":"Models Reference","text":"<p>This section provides detailed documentation of the model architectures and configurations available in Tabular SSL.</p>"},{"location":"reference/models/#tabularssl","title":"TabularSSL","text":"<p>The main model class for self-supervised learning on tabular data.</p> <pre><code>from tabular_ssl import TabularSSL\n</code></pre>"},{"location":"reference/models/#architecture","title":"Architecture","text":"<p>The TabularSSL model consists of:</p> <ol> <li>Input Layer</li> <li>Handles mixed data types (numerical and categorical)</li> <li>Feature embedding layer</li> <li> <p>Positional encoding</p> </li> <li> <p>Transformer Encoder</p> </li> <li>Multi-head self-attention</li> <li>Feed-forward networks</li> <li>Layer normalization</li> <li> <p>Residual connections</p> </li> <li> <p>Output Layer</p> </li> <li>Feature reconstruction</li> <li>Task-specific heads</li> </ol>"},{"location":"reference/models/#configuration","title":"Configuration","text":"<p>The model uses Hydra's configuration system with the <code>_target_</code> pattern for flexible component instantiation.</p>"},{"location":"reference/models/#example-configuration","title":"Example Configuration","text":"<pre><code>_target_: tabular_ssl.models.TabularSSL\n\n# Model components\nevent_encoder:\n  _target_: tabular_ssl.models.encoders.EventEncoder\n  input_dim: 10\n  hidden_dims: [64, 32]\n  output_dim: 16\n\nsequence_encoder:\n  _target_: tabular_ssl.models.encoders.TransformerEncoder\n  input_dim: 16\n  hidden_dim: 32\n  num_layers: 2\n  dropout: 0.1\n  num_heads: 4\n\nembedding:\n  _target_: tabular_ssl.models.embeddings.FeatureEmbedding\n  embedding_dims:\n    - [5, 8]  # 5 categories, 8-dimensional embedding\n    - [3, 4]  # 3 categories, 4-dimensional embedding\n\nprojection_head:\n  _target_: tabular_ssl.models.heads.ProjectionHead\n  input_dim: 32\n  hidden_dim: 16\n  output_dim: 8\n\nprediction_head:\n  _target_: tabular_ssl.models.heads.PredictionHead\n  input_dim: 8\n  num_classes: 2\n  dropout: 0.1\n</code></pre>"},{"location":"reference/models/#available-encoders","title":"Available Encoders","text":"<ol> <li> <p>Transformer Encoder <pre><code>_target_: tabular_ssl.models.encoders.TransformerEncoder\ninput_dim: 16\nhidden_dim: 32\nnum_layers: 2\nnum_heads: 4\ndropout: 0.1\n</code></pre></p> </li> <li> <p>RNN Encoder <pre><code>_target_: tabular_ssl.models.encoders.RNNEncoder\ninput_dim: 16\nhidden_dim: 32\nnum_layers: 2\ndropout: 0.1\nbidirectional: true\n</code></pre></p> </li> <li> <p>LSTM Encoder <pre><code>_target_: tabular_ssl.models.encoders.LSTMEncoder\ninput_dim: 16\nhidden_dim: 32\nnum_layers: 2\ndropout: 0.1\nbidirectional: true\n</code></pre></p> </li> <li> <p>GRU Encoder <pre><code>_target_: tabular_ssl.models.encoders.GRUEncoder\ninput_dim: 16\nhidden_dim: 32\nnum_layers: 2\ndropout: 0.1\nbidirectional: true\n</code></pre></p> </li> <li> <p>SSM Encoder <pre><code>_target_: tabular_ssl.models.encoders.SSMEncoder\ninput_dim: 16\nhidden_dim: 32\nstate_dim: 32\nuse_gate: true\n</code></pre></p> </li> <li> <p>S4 Encoder <pre><code>_target_: tabular_ssl.models.encoders.S4Encoder\ninput_dim: 16\nhidden_dim: 32\nmax_sequence_length: 1024\nuse_learnable_dt: true\nuse_initial_state: true\n</code></pre></p> </li> </ol>"},{"location":"reference/models/#methods","title":"Methods","text":""},{"location":"reference/models/#traindata-batch_size32-epochs100-learning_rate1e-4","title":"<code>train(data, batch_size=32, epochs=100, learning_rate=1e-4)</code>","text":"<p>Train the model using self-supervised learning.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>batch_size</code> (int): Batch size for training - <code>epochs</code> (int): Number of training epochs - <code>learning_rate</code> (float): Learning rate</p> <p>Returns: - <code>dict</code>: Training history</p>"},{"location":"reference/models/#predictdata","title":"<code>predict(data)</code>","text":"<p>Make predictions on new data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data</p> <p>Returns: - <code>np.ndarray</code>: Model predictions</p>"},{"location":"reference/models/#savepath","title":"<code>save(path)</code>","text":"<p>Save the model to disk.</p> <p>Parameters: - <code>path</code> (str): Path to save the model</p>"},{"location":"reference/models/#loadpath","title":"<code>load(path)</code>","text":"<p>Load a model from disk.</p> <p>Parameters: - <code>path</code> (str): Path to the saved model</p> <p>Returns: - <code>TabularSSL</code>: Loaded model</p>"},{"location":"reference/models/#model-components","title":"Model Components","text":""},{"location":"reference/models/#feature-embedding","title":"Feature Embedding","text":"<pre><code>from tabular_ssl.models.embeddings import FeatureEmbedding\n\nembedding = FeatureEmbedding(\n    input_dim=10,\n    embedding_dim=64\n)\n</code></pre>"},{"location":"reference/models/#transformer-encoder","title":"Transformer Encoder","text":"<pre><code>from tabular_ssl.models.encoders import TransformerEncoder\n\nencoder = TransformerEncoder(\n    input_dim=64,\n    hidden_dim=256,\n    num_layers=4,\n    num_heads=4\n)\n</code></pre>"},{"location":"reference/models/#task-heads","title":"Task Heads","text":"<pre><code>from tabular_ssl.models.heads import TaskHead\n\nhead = TaskHead(\n    input_dim=256,\n    output_dim=10\n)\n</code></pre>"},{"location":"reference/models/#model-variants","title":"Model Variants","text":""},{"location":"reference/models/#tabularssl-large","title":"TabularSSL-Large","text":"<pre><code>_target_: tabular_ssl.models.TabularSSLLarge\ninput_dim: 10\nhidden_dim: 512\nnum_layers: 6\nnum_heads: 8\n</code></pre>"},{"location":"reference/models/#tabularssl-small","title":"TabularSSL-Small","text":"<pre><code>_target_: tabular_ssl.models.TabularSSLSmall\ninput_dim: 10\nhidden_dim: 128\nnum_layers: 2\nnum_heads: 2\n</code></pre>"},{"location":"reference/models/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>How-to Guides - Training guides</li> <li>Explanation - Architecture details </li> </ul>"},{"location":"reference/utils/","title":"Utility Functions Reference","text":"<p>This section provides detailed documentation of the utility functions and tools in Tabular SSL.</p>"},{"location":"reference/utils/#evaluation-utilities","title":"Evaluation Utilities","text":""},{"location":"reference/utils/#model-evaluation","title":"Model Evaluation","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\n</code></pre>"},{"location":"reference/utils/#cross-validation","title":"Cross-Validation","text":"<pre><code>from tabular_ssl.utils import cross_validate\n\ncv_results = cross_validate(\n    model,\n    data,\n    n_splits=5,\n    metrics=['accuracy', 'f1']\n)\n</code></pre>"},{"location":"reference/utils/#visualization-utilities","title":"Visualization Utilities","text":""},{"location":"reference/utils/#training-history","title":"Training History","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"reference/utils/#performance-plots","title":"Performance Plots","text":"<pre><code>from tabular_ssl.utils import plot_performance\n\nfig = plot_performance(\n    model,\n    test_data,\n    plot_types=['confusion_matrix', 'roc_curve']\n)\nfig.show()\n</code></pre>"},{"location":"reference/utils/#model-interpretation","title":"Model Interpretation","text":""},{"location":"reference/utils/#feature-importance","title":"Feature Importance","text":"<pre><code>from tabular_ssl.utils import get_feature_importance\n\nimportance = get_feature_importance(model, test_data)\n</code></pre>"},{"location":"reference/utils/#shap-values","title":"SHAP Values","text":"<pre><code>from tabular_ssl.utils import get_shap_values\n\nshap_values = get_shap_values(model, test_data)\n</code></pre>"},{"location":"reference/utils/#hyperparameter-tuning","title":"Hyperparameter Tuning","text":""},{"location":"reference/utils/#grid-search","title":"Grid Search","text":"<pre><code>from tabular_ssl.utils import grid_search\n\nbest_params = grid_search(\n    model_class=TabularSSL,\n    param_grid={\n        'hidden_dim': [128, 256, 512],\n        'num_layers': [2, 4, 6]\n    },\n    train_data=train_data,\n    val_data=val_data\n)\n</code></pre>"},{"location":"reference/utils/#random-search","title":"Random Search","text":"<pre><code>from tabular_ssl.utils import random_search\n\nbest_params = random_search(\n    model_class=TabularSSL,\n    param_distributions={\n        'hidden_dim': [128, 256, 512],\n        'num_layers': [2, 4, 6]\n    },\n    train_data=train_data,\n    val_data=val_data,\n    n_iter=10\n)\n</code></pre>"},{"location":"reference/utils/#data-utilities","title":"Data Utilities","text":""},{"location":"reference/utils/#data-validation","title":"Data Validation","text":"<pre><code>from tabular_ssl.utils import validate_data\n\nvalidation_results = validate_data(data)\n</code></pre>"},{"location":"reference/utils/#feature-selection","title":"Feature Selection","text":"<pre><code>from tabular_ssl.utils import select_features\n\nselected_features = select_features(\n    data,\n    target_col='target',\n    method='importance',\n    threshold=0.01\n)\n</code></pre>"},{"location":"reference/utils/#model-utilities","title":"Model Utilities","text":""},{"location":"reference/utils/#model-saving","title":"Model Saving","text":"<pre><code>from tabular_ssl.utils import save_model\n\nsave_model(model, 'model.pt')\n</code></pre>"},{"location":"reference/utils/#model-loading","title":"Model Loading","text":"<pre><code>from tabular_ssl.utils import load_model\n\nmodel = load_model('model.pt')\n</code></pre>"},{"location":"reference/utils/#training-utilities","title":"Training Utilities","text":""},{"location":"reference/utils/#learning-rate-scheduling","title":"Learning Rate Scheduling","text":"<pre><code>from tabular_ssl.utils import get_lr_scheduler\n\nscheduler = get_lr_scheduler(\n    initial_lr=1e-3,\n    scheduler_type='cosine',\n    warmup_epochs=5\n)\n</code></pre>"},{"location":"reference/utils/#early-stopping","title":"Early Stopping","text":"<pre><code>from tabular_ssl.utils import EarlyStopping\n\nearly_stopping = EarlyStopping(\n    patience=10,\n    min_delta=0.001\n)\n</code></pre>"},{"location":"reference/utils/#common-functions","title":"Common Functions","text":""},{"location":"reference/utils/#metrics","title":"Metrics","text":"<pre><code>from tabular_ssl.utils import (\n    accuracy_score,\n    f1_score,\n    precision_score,\n    recall_score\n)\n\n# Compute metrics\nacc = accuracy_score(y_true, y_pred)\nf1 = f1_score(y_true, y_pred)\n</code></pre>"},{"location":"reference/utils/#data-processing","title":"Data Processing","text":"<pre><code>from tabular_ssl.utils import (\n    normalize_data,\n    encode_categorical,\n    handle_missing\n)\n\n# Process data\nnormalized_data = normalize_data(data)\nencoded_data = encode_categorical(data, categorical_cols)\ncleaned_data = handle_missing(data, strategy='mean')\n</code></pre>"},{"location":"reference/utils/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate evaluation metrics</li> <li>Implement proper cross-validation</li> <li>Visualize results for better understanding</li> <li>Document utility function usage</li> <li>Handle errors gracefully</li> <li>Use type hints for better code clarity</li> <li>Add proper docstrings</li> <li>Include examples in documentation</li> </ol>"},{"location":"reference/utils/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>How-to Guides - Evaluation guides</li> <li>Tutorials - Usage examples </li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Tabular SSL tutorials section. Here you'll find step-by-step guides to help you get started with the library.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"<ul> <li>Getting Started - Learn the basics of Tabular SSL</li> <li>Basic Usage - Explore common use cases and patterns</li> </ul>"},{"location":"tutorials/#whats-next","title":"What's Next?","text":"<p>After completing the tutorials, you might want to:</p> <ol> <li>Check out the How-to Guides for practical solutions</li> <li>Read the API Reference for detailed documentation</li> <li>Learn about the SSL Methods in depth </li> </ol>"},{"location":"tutorials/basic-usage/","title":"Basic Usage","text":"<p>This tutorial covers common use cases and patterns for working with Tabular SSL.</p>"},{"location":"tutorials/basic-usage/#working-with-different-data-types","title":"Working with Different Data Types","text":""},{"location":"tutorials/basic-usage/#numerical-data","title":"Numerical Data","text":"<pre><code>import pandas as pd\nfrom tabular_ssl import TabularSSL\nfrom hydra.utils import instantiate\nfrom omegaconf import OmegaConf\n\n# Create sample numerical data\ndata = pd.DataFrame({\n    'feature1': [1.0, 2.0, 3.0],\n    'feature2': [4.0, 5.0, 6.0]\n})\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 2\n})\n\n# Initialize and train model\nmodel = instantiate(config)\nmodel.train(data)\n</code></pre>"},{"location":"tutorials/basic-usage/#categorical-data","title":"Categorical Data","text":"<pre><code># Create sample categorical data\ndata = pd.DataFrame({\n    'category1': ['A', 'B', 'A'],\n    'category2': ['X', 'Y', 'Z']\n})\n\n# Preprocess categorical data\nfrom tabular_ssl.data import DataLoader\ndata_loader = DataLoader()\nprocessed_data = data_loader.preprocess(data, categorical_cols=['category1', 'category2'])\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': processed_data.shape[1]\n})\n\n# Train model\nmodel = instantiate(config)\nmodel.train(processed_data)\n</code></pre>"},{"location":"tutorials/basic-usage/#mixed-data-types","title":"Mixed Data Types","text":"<pre><code># Create sample mixed data\ndata = pd.DataFrame({\n    'numeric': [1.0, 2.0, 3.0],\n    'category': ['A', 'B', 'A']\n})\n\n# Preprocess data\nprocessed_data = data_loader.preprocess(\n    data,\n    categorical_cols=['category']\n)\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': processed_data.shape[1]\n})\n\n# Train model\nmodel = instantiate(config)\nmodel.train(processed_data)\n</code></pre>"},{"location":"tutorials/basic-usage/#model-configuration","title":"Model Configuration","text":""},{"location":"tutorials/basic-usage/#custom-architecture","title":"Custom Architecture","text":"<pre><code># Create configuration with custom architecture\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.TransformerEncoder',\n        'input_dim': 10,\n        'hidden_dim': 512,    # Larger hidden dimension\n        'num_layers': 6,      # More transformer layers\n        'num_heads': 8,       # More attention heads\n        'dropout': 0.2        # Higher dropout\n    },\n    'mask_ratio': 0.2         # Higher masking ratio\n})\n\n# Initialize model\nmodel = instantiate(config)\n</code></pre>"},{"location":"tutorials/basic-usage/#training-configuration","title":"Training Configuration","text":"<pre><code># Create training configuration\ntrain_config = OmegaConf.create({\n    'batch_size': 64,         # Larger batch size\n    'epochs': 200,            # More epochs\n    'learning_rate': 5e-5,    # Lower learning rate\n    'weight_decay': 1e-4      # L2 regularization\n})\n\n# Train model\nhistory = model.train(\n    data=processed_data,\n    **train_config\n)\n</code></pre>"},{"location":"tutorials/basic-usage/#model-evaluation","title":"Model Evaluation","text":""},{"location":"tutorials/basic-usage/#computing-metrics","title":"Computing Metrics","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\nprint(metrics)\n</code></pre>"},{"location":"tutorials/basic-usage/#visualization","title":"Visualization","text":"<pre><code>from tabular_ssl.utils import plot_training_history\nimport matplotlib.pyplot as plt\n\n# Plot training history\nfig = plot_training_history(history)\nplt.show()\n\n# Save the plot\nfig.savefig('training_history.png')\n</code></pre>"},{"location":"tutorials/basic-usage/#model-persistence","title":"Model Persistence","text":""},{"location":"tutorials/basic-usage/#saving-and-loading","title":"Saving and Loading","text":"<pre><code># Save model\nmodel.save('my_model.pt')\n\n# Load model\nloaded_model = TabularSSL.load('my_model.pt')\n</code></pre>"},{"location":"tutorials/basic-usage/#using-different-encoders","title":"Using Different Encoders","text":""},{"location":"tutorials/basic-usage/#transformer-encoder","title":"Transformer Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.TransformerEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 4,\n        'num_heads': 4\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#rnn-encoder","title":"RNN Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.RNNEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 2,\n        'bidirectional': true\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#lstm-encoder","title":"LSTM Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.LSTMEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 2,\n        'bidirectional': true\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#understanding-hydra-configuration","title":"Understanding Hydra Configuration","text":""},{"location":"tutorials/basic-usage/#basic-concepts","title":"Basic Concepts","text":"<p>Hydra is a framework for elegantly configuring complex applications. Here are the key concepts:</p> <ol> <li> <p>Configuration Files <pre><code># configs/model/default.yaml\n_target_: tabular_ssl.models.TabularSSL\ninput_dim: 10\nsequence_encoder:\n  _target_: tabular_ssl.models.encoders.TransformerEncoder\n  input_dim: 10\n  hidden_dim: 256\n</code></pre></p> </li> <li> <p>Configuration Groups <pre><code># configs/model/transformer.yaml\n_target_: tabular_ssl.models.encoders.TransformerEncoder\ninput_dim: ${model.input_dim}\nhidden_dim: 256\nnum_heads: 4\n\n# configs/model/rnn.yaml\n_target_: tabular_ssl.models.encoders.RNNEncoder\ninput_dim: ${model.input_dim}\nhidden_dim: 256\nnum_layers: 2\n</code></pre></p> </li> <li> <p>Configuration Composition <pre><code># configs/experiment/transformer_experiment.yaml\ndefaults:\n  - model: transformer\n  - data: default\n  - trainer: default\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#using-hydra-in-code","title":"Using Hydra in Code","text":"<ol> <li> <p>Loading Configurations <pre><code>from hydra import compose, initialize\n\n# Initialize Hydra\nwith initialize(config_path=\"configs\"):\n    # Load default config\n    config = compose(config_name=\"config\")\n\n    # Load specific experiment\n    experiment_config = compose(config_name=\"experiment/transformer_experiment\")\n</code></pre></p> </li> <li> <p>Instantiating Objects <pre><code>from hydra.utils import instantiate\n\n# Create model from config\nmodel = instantiate(config.model)\n\n# Create optimizer\noptimizer = instantiate(config.optimizer, params=model.parameters())\n</code></pre></p> </li> <li> <p>Overriding Configuration <pre><code># Override specific values\nconfig = compose(\n    config_name=\"config\",\n    overrides=[\"model.sequence_encoder.hidden_dim=512\"]\n)\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#advanced-features","title":"Advanced Features","text":"<ol> <li> <p>Variable Interpolation <pre><code># configs/model/default.yaml\ninput_dim: 10\nsequence_encoder:\n  input_dim: ${model.input_dim}  # References parent config\n  hidden_dim: ${oc.env:HIDDEN_DIM,256}  # Uses environment variable with default\n</code></pre></p> </li> <li> <p>Configuration Inheritance <pre><code># configs/model/base.yaml\n_target_: tabular_ssl.models.TabularSSL\ninput_dim: 10\n\n# configs/model/large.yaml\ndefaults:\n  - base\nhidden_dim: 512\nnum_layers: 6\n</code></pre></p> </li> <li> <p>Structured Configs <pre><code>from dataclasses import dataclass\nfrom omegaconf import MISSING\n\n@dataclass\nclass ModelConfig:\n    _target_: str = MISSING\n    input_dim: int = MISSING\n    hidden_dim: int = 256\n\n@dataclass\nclass Config:\n    model: ModelConfig = MISSING\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Configuration Organization</li> <li>Keep related configs together</li> <li>Use meaningful names</li> <li> <p>Document configuration options</p> </li> <li> <p>Default Values</p> </li> <li>Provide sensible defaults</li> <li>Use type hints</li> <li> <p>Document parameter ranges</p> </li> <li> <p>Error Handling <pre><code>from omegaconf import OmegaConf\n\n# Validate config\ntry:\n    OmegaConf.to_container(config, resolve=True)\nexcept Exception as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre></p> </li> <li> <p>Configuration Logging <pre><code># Log configuration\nprint(OmegaConf.to_yaml(config))\n\n# Save configuration\nOmegaConf.save(config, \"config.yaml\")\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Explore How-to Guides for more specific use cases</li> <li>Check the API Reference for detailed documentation</li> <li>Learn about SSL Methods in depth </li> </ul>"},{"location":"tutorials/getting-started/","title":"Getting Started with Tabular SSL","text":"<p>This tutorial will guide you through the process of setting up and using the Tabular SSL library for self-supervised learning on tabular data.</p>"},{"location":"tutorials/getting-started/#installation","title":"Installation","text":"<p>First, install the library using pip:</p> <pre><code>pip install tabular-ssl\n</code></pre>"},{"location":"tutorials/getting-started/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of how to use Tabular SSL:</p> <pre><code>import pandas as pd\nfrom tabular_ssl import TabularSSL\nfrom tabular_ssl.data import DataLoader\n\n# Load your data\ndata_loader = DataLoader()\ndata = data_loader.load_data('your_data.csv')\n\n# Initialize the model\nmodel = TabularSSL(\n    input_dim=data.shape[1],\n    hidden_dim=256,\n    num_layers=4,\n    num_heads=4\n)\n\n# Train the model\nhistory = model.train(\n    data=data,\n    batch_size=32,\n    epochs=100,\n    learning_rate=1e-4\n)\n\n# Make predictions\npredictions = model.predict(new_data)\n</code></pre>"},{"location":"tutorials/getting-started/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"tutorials/getting-started/#1-data-preparation","title":"1. Data Preparation","text":"<p>First, prepare your data:</p> <pre><code># Load and preprocess your data\ndata_loader = DataLoader()\ndata = data_loader.load_data('your_data.csv')\n\n# If you have categorical columns, specify them\ncategorical_cols = ['category1', 'category2']\ndata = data_loader.preprocess(data, categorical_cols=categorical_cols)\n</code></pre>"},{"location":"tutorials/getting-started/#2-model-configuration","title":"2. Model Configuration","text":"<p>Configure your model with appropriate parameters:</p> <pre><code>model = TabularSSL(\n    input_dim=data.shape[1],  # Number of features\n    hidden_dim=256,           # Hidden layer dimension\n    num_layers=4,             # Number of transformer layers\n    num_heads=4,              # Number of attention heads\n    dropout=0.1,              # Dropout rate\n    mask_ratio=0.15           # Feature masking ratio\n)\n</code></pre>"},{"location":"tutorials/getting-started/#3-training","title":"3. Training","text":"<p>Train the model using self-supervised learning:</p> <pre><code>history = model.train(\n    data=data,\n    batch_size=32,\n    epochs=100,\n    learning_rate=1e-4\n)\n</code></pre>"},{"location":"tutorials/getting-started/#4-evaluation","title":"4. Evaluation","text":"<p>Evaluate your model's performance:</p> <pre><code>from tabular_ssl.utils import evaluate_model, plot_training_history\n\n# Plot training history\nplot_training_history(history)\n\n# Evaluate model performance\nmetrics = evaluate_model(model, test_data, metrics=['accuracy', 'f1'])\nprint(metrics)\n</code></pre>"},{"location":"tutorials/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Basic Usage tutorial for more advanced examples</li> <li>Explore the API Reference for detailed documentation</li> <li>Learn about different SSL Methods you can use</li> </ul>"},{"location":"tutorials/getting-started/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorials/getting-started/#memory-issues","title":"Memory Issues","text":"<p>If you encounter memory issues with large datasets:</p> <pre><code># Use a smaller batch size\nmodel.train(data, batch_size=16)\n\n# Or reduce model complexity\nmodel = TabularSSL(\n    input_dim=data.shape[1],\n    hidden_dim=128,  # Reduced from 256\n    num_layers=2,    # Reduced from 4\n    num_heads=2      # Reduced from 4\n)\n</code></pre>"},{"location":"tutorials/getting-started/#training-stability","title":"Training Stability","text":"<p>For better training stability:</p> <pre><code># Use a lower learning rate\nmodel.train(data, learning_rate=1e-5)\n\n# Increase the number of epochs\nmodel.train(data, epochs=200)\n</code></pre>"},{"location":"tutorials/getting-started/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guide </li> </ul>"}]}