{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Tabular SSL Documentation","text":"<p>Welcome to the official documentation for the Tabular SSL library. This documentation is organized following the Di\u00e1taxis framework to provide you with the most effective learning and reference experience.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#tutorials","title":"Tutorials","text":"<p>Learn how to use Tabular SSL through step-by-step guides. Start here if you're new to the library.</p> <ul> <li>Getting Started</li> <li>Basic Usage</li> <li>Creating Custom Components</li> </ul>"},{"location":"#how-to-guides","title":"How-to Guides","text":"<p>Find practical solutions to specific problems and tasks.</p> <ul> <li>Data Preparation</li> <li>Model Training</li> <li>Evaluation</li> <li>Configuring Experiments</li> </ul>"},{"location":"#reference","title":"Reference","text":"<p>Detailed technical documentation of the library's components.</p> <ul> <li>API Reference</li> <li>Models</li> <li>Data Utilities</li> <li>Utility Functions</li> <li>Configuration</li> </ul>"},{"location":"#explanation","title":"Explanation","text":"<p>Understand the concepts and design decisions behind Tabular SSL.</p> <ul> <li>Architecture Overview</li> <li>Component Registry</li> <li>SSL Methods</li> <li>Performance Considerations</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import hydra\nfrom omegaconf import DictConfig\n\n@hydra.main(config_path=\"../configs\", config_name=\"config\")\ndef main(config: DictConfig):\n    # Create model from configuration\n    from tabular_ssl.models.base import BaseModel\n    model = BaseModel(config)\n\n    # Train model with given config\n    trainer = hydra.utils.instantiate(config.trainer)\n    trainer.fit(model, datamodule=hydra.utils.instantiate(config.data))\n\n    # Make predictions\n    trainer.test(model, datamodule=hydra.utils.instantiate(config.data))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/yourusername/tabular-ssl.git\ncd tabular-ssl\n\n# Install dependencies\npip install -r requirements.txt\n\n# Install the package in development mode\npip install -e .\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Component Registry: Modular design with type-safe component registration</li> <li>Configuration Management: Hierarchical configuration with Hydra</li> <li>Self-Supervised Learning: Multiple SSL methods for tabular data</li> <li>Flexible Architecture: Mix and match components for custom models</li> <li>Experiment Management: Easy experiment configuration and tracking</li> <li>Type Safety: Pydantic-based configuration validation</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. </p>"},{"location":"explanation/","title":"Explanation","text":"<p>This section provides background information and explanations of the concepts and design decisions behind Tabular SSL.</p>"},{"location":"explanation/#available-topics","title":"Available Topics","text":"<ul> <li>Architecture Overview - System design and components</li> <li>SSL Methods - Self-supervised learning approaches</li> <li>Performance Considerations - Optimization and scaling</li> </ul>"},{"location":"explanation/#key-concepts","title":"Key Concepts","text":""},{"location":"explanation/#self-supervised-learning","title":"Self-Supervised Learning","text":"<p>Self-supervised learning (SSL) is a machine learning paradigm where models learn from unlabeled data by creating their own supervision signals. In the context of tabular data, this involves:</p> <ul> <li>Feature masking and reconstruction</li> <li>Contrastive learning</li> <li>Predictive tasks</li> </ul>"},{"location":"explanation/#architecture","title":"Architecture","text":"<p>The Tabular SSL architecture is designed to:</p> <ul> <li>Handle mixed data types (numerical and categorical)</li> <li>Process variable-length sequences</li> <li>Learn robust representations</li> <li>Scale to large datasets</li> </ul>"},{"location":"explanation/#performance","title":"Performance","text":"<p>Key performance considerations include:</p> <ul> <li>Memory efficiency</li> <li>Training speed</li> <li>Model complexity</li> <li>Inference latency</li> </ul>"},{"location":"explanation/#related-resources","title":"Related Resources","text":"<ul> <li>Tutorials - Step-by-step guides</li> <li>How-to Guides - Practical solutions</li> <li>Reference - Technical documentation </li> </ul>"},{"location":"explanation/architecture/","title":"Architecture Overview","text":"<p>This section explains the architecture and design decisions behind Tabular SSL.</p>"},{"location":"explanation/architecture/#system-design","title":"System Design","text":""},{"location":"explanation/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The Tabular SSL system consists of several key components:</p> <ol> <li>Data Processing Layer</li> <li>Data loading and validation</li> <li>Feature preprocessing</li> <li> <p>Data augmentation</p> </li> <li> <p>Model Layer</p> </li> <li>Component Registry for modular design</li> <li>Feature embedding</li> <li>Encoder components (Transformer, RNN, LSTM, S4, etc.)</li> <li> <p>Task-specific heads</p> </li> <li> <p>Training Layer</p> </li> <li>Self-supervised learning</li> <li>Optimization</li> <li> <p>Monitoring</p> </li> <li> <p>Configuration Layer</p> </li> <li>Hydra configuration management</li> <li>Experiment tracking</li> <li>Parameter validation</li> </ol>"},{"location":"explanation/architecture/#component-registry","title":"Component Registry","text":"<p>One of the core architectural features of Tabular SSL is the Component Registry pattern, which enables a highly modular and extensible design.</p>"},{"location":"explanation/architecture/#registry-design","title":"Registry Design","text":"<p>The Component Registry is a central repository that maps component names to their implementations:</p> <pre><code>class ComponentRegistry:\n    \"\"\"Registry for model components.\"\"\"\n\n    _components: ClassVar[Dict[str, Type['BaseComponent']]] = {}\n\n    @classmethod\n    def register(cls, name: str) -&gt; Type[T]:\n        \"\"\"Register a component class.\"\"\"\n        def decorator(component_cls: Type[T]) -&gt; Type[T]:\n            cls._components[name] = component_cls\n            return component_cls\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -&gt; Type['BaseComponent']:\n        \"\"\"Get a component class by name.\"\"\"\n        if name not in cls._components:\n            raise KeyError(f\"Component {name} not found in registry\")\n        return cls._components[name]\n</code></pre>"},{"location":"explanation/architecture/#component-configuration","title":"Component Configuration","text":"<p>Each component has its own configuration class that inherits from <code>ComponentConfig</code>:</p> <pre><code>class ComponentConfig(PydanticBaseModel):\n    \"\"\"Base configuration for components.\"\"\"\n\n    name: str = Field(..., description=\"Name of the component\")\n    type: str = Field(..., description=\"Type of the component\")\n\n    @validator('type')\n    def validate_type(cls, v: str) -&gt; str:\n        \"\"\"Validate that the component type exists in the registry.\"\"\"\n        if v not in ComponentRegistry._components:\n            raise ValueError(f\"Component type {v} not found in registry\")\n        return v\n</code></pre>"},{"location":"explanation/architecture/#component-initialization","title":"Component Initialization","text":"<p>Components are initialized using their configuration:</p> <pre><code>def _init_component(self, config: ComponentConfig) -&gt; BaseComponent:\n    \"\"\"Initialize a component from its configuration.\"\"\"\n    component_cls = ComponentRegistry.get(config.type)\n    return component_cls(config)\n</code></pre>"},{"location":"explanation/architecture/#benefits-of-the-registry-pattern","title":"Benefits of the Registry Pattern","text":"<ol> <li>Modularity: Components can be added, removed, or replaced independently</li> <li>Validation: Configuration is validated before components are initialized</li> <li>Extensibility: New components can be added without modifying existing code</li> <li>Dynamic Loading: Components are loaded at runtime based on configuration</li> <li>Type Safety: Component types are checked during initialization</li> </ol>"},{"location":"explanation/architecture/#component-details","title":"Component Details","text":""},{"location":"explanation/architecture/#base-components","title":"Base Components","text":"<p>Tabular SSL defines several base component types:</p> <ol> <li>EventEncoder: Encodes individual events or timesteps</li> <li>SequenceEncoder: Encodes sequences of events</li> <li>EmbeddingLayer: Handles embedding of categorical features</li> <li>ProjectionHead: Projects encoded representations to a different space</li> <li>PredictionHead: Generates predictions from encoded representations</li> </ol> <p>Each component type has multiple implementations that can be selected via configuration.</p>"},{"location":"explanation/architecture/#available-components","title":"Available Components","text":""},{"location":"explanation/architecture/#event-encoders","title":"Event Encoders","text":"<ul> <li><code>mlp_event_encoder</code>: MLP-based event encoder</li> <li><code>autoencoder</code>: Autoencoder-based event encoder</li> <li><code>contrastive</code>: Contrastive learning event encoder</li> </ul>"},{"location":"explanation/architecture/#sequence-encoders","title":"Sequence Encoders","text":"<ul> <li><code>rnn</code>: Basic RNN encoder</li> <li><code>lstm</code>: LSTM encoder</li> <li><code>gru</code>: GRU encoder</li> <li><code>transformer</code>: Transformer encoder</li> <li><code>s4</code>: Diagonal State Space Model (S4) encoder</li> </ul>"},{"location":"explanation/architecture/#embedding-layers","title":"Embedding Layers","text":"<ul> <li><code>categorical_embedding</code>: Embedding layer for categorical variables</li> </ul>"},{"location":"explanation/architecture/#projection-heads","title":"Projection Heads","text":"<ul> <li><code>mlp_projection</code>: MLP-based projection head</li> </ul>"},{"location":"explanation/architecture/#prediction-heads","title":"Prediction Heads","text":"<ul> <li><code>classification</code>: Classification head</li> </ul>"},{"location":"explanation/architecture/#corruption-strategies","title":"Corruption Strategies","text":"<ul> <li><code>random_masking</code>: Random masking corruption</li> <li><code>gaussian_noise</code>: Gaussian noise corruption</li> <li><code>swapping</code>: Feature swapping corruption</li> <li><code>vime</code>: VIME-style corruption</li> <li><code>corruption_pipeline</code>: Pipeline of multiple corruption strategies</li> </ul>"},{"location":"explanation/architecture/#configuration-system","title":"Configuration System","text":"<p>The system uses Hydra's configuration system with structured configuration files:</p> <pre><code>configs/\n\u251c\u2500\u2500 config.yaml                # Main configuration\n\u251c\u2500\u2500 model/                     # Model configurations\n\u2502   \u251c\u2500\u2500 default.yaml          # Default model config\n\u2502   \u251c\u2500\u2500 event_encoder/        # Event encoder configs\n\u2502   \u251c\u2500\u2500 sequence_encoder/     # Sequence encoder configs\n\u2502   \u251c\u2500\u2500 embedding/            # Embedding configs\n\u2502   \u251c\u2500\u2500 projection_head/      # Projection head configs\n\u2502   \u2514\u2500\u2500 prediction_head/      # Prediction head configs\n\u251c\u2500\u2500 data/                     # Data configurations\n\u251c\u2500\u2500 trainer/                  # Training configurations\n\u251c\u2500\u2500 callbacks/                # Callback configurations\n\u251c\u2500\u2500 logger/                   # Logger configurations\n\u251c\u2500\u2500 experiment/               # Experiment configurations\n\u251c\u2500\u2500 hydra/                    # Hydra-specific configurations\n\u2514\u2500\u2500 paths/                    # Path configurations\n</code></pre>"},{"location":"explanation/architecture/#configuration-composition","title":"Configuration Composition","text":"<p>Configurations are composed hierarchically:</p> <pre><code># configs/model/default.yaml\ndefaults:\n  - _self_\n  - event_encoder: mlp.yaml\n  - sequence_encoder: transformer.yaml\n  - embedding: categorical.yaml\n  - projection_head: mlp.yaml\n  - prediction_head: classification.yaml\n\n_target_: tabular_ssl.models.base.BaseModel\n\nmodel:\n  name: tabular_ssl_model\n  type: base\n  event_encoder: ${event_encoder}\n  sequence_encoder: ${sequence_encoder}\n  embedding: ${embedding}\n  projection_head: ${projection_head}\n  prediction_head: ${prediction_head}\n</code></pre>"},{"location":"explanation/architecture/#experiment-configuration","title":"Experiment Configuration","text":"<p>Experiments override specific parts of the configuration:</p> <pre><code># configs/experiment/s4_sequence.yaml\n# @package _global_\n\ndefaults:\n  - override /model/sequence_encoder: s4.yaml\n  - override /trainer: default.yaml\n  - override /model: default.yaml\n  - override /callbacks: default.yaml\n  - _self_\n\ntags: [\"s4\", \"sequence\"]\n\ntrainer:\n  max_epochs: 50\n  gradient_clip_val: 0.5\n\nmodel:\n  optimizer:\n    lr: 5.0e-4\n    weight_decay: 0.05\n</code></pre>"},{"location":"explanation/architecture/#hydra-to-component-integration","title":"Hydra-to-Component Integration","text":"<p>The system translates Hydra configurations to component configurations:</p> <pre><code># Convert Hydra configs to ComponentConfigs\nself.event_encoder_config = ComponentConfig.from_hydra(config.model.event_encoder)\nself.sequence_encoder_config = ComponentConfig.from_hydra(config.model.sequence_encoder)\n\n# Initialize components\nself.event_encoder = self._init_component(self.event_encoder_config)\nself.sequence_encoder = self._init_component(self.sequence_encoder_config)\n</code></pre>"},{"location":"explanation/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"explanation/architecture/#why-component-registry","title":"Why Component Registry?","text":"<p>The Component Registry pattern was chosen for several reasons:</p> <ol> <li>Separation of Concerns</li> <li>Components focus on their specific functionality</li> <li>Registry handles component discovery and initialization</li> <li> <p>Configuration handles component parameters</p> </li> <li> <p>Extensibility</p> </li> <li>New components can be added without modifying existing code</li> <li>Custom components can be registered by users</li> <li> <p>Experiments can mix and match components</p> </li> <li> <p>Validation</p> </li> <li>Component types are validated during initialization</li> <li>Configuration parameters are validated using Pydantic</li> <li>Better error messages for misconfiguration</li> </ol>"},{"location":"explanation/architecture/#why-hydra-configuration","title":"Why Hydra Configuration?","text":"<p>Hydra provides several benefits for configuration management:</p> <ol> <li>Hierarchical Configuration</li> <li>Configurations are organized into groups</li> <li>Defaults can be overridden selectively</li> <li> <p>Parameters can be composed from multiple sources</p> </li> <li> <p>Command-line Overrides</p> </li> <li>Parameters can be changed at runtime</li> <li>No need to modify configuration files</li> <li> <p>Experiment parameters are explicit</p> </li> <li> <p>Multirun Capabilities</p> </li> <li>Parameter sweeps for experimentation</li> <li>Parallel execution of multiple runs</li> <li>Organized output directories</li> </ol>"},{"location":"explanation/architecture/#implementation-details","title":"Implementation Details","text":""},{"location":"explanation/architecture/#code-organization","title":"Code Organization","text":"<pre><code>src/\n\u251c\u2500\u2500 tabular_ssl/              # Core package\n\u2502   \u251c\u2500\u2500 data/                # Data loading and processing\n\u2502   \u251c\u2500\u2500 models/              # Model implementations\n\u2502   \u2502   \u251c\u2500\u2500 base.py         # Base model and component registry\n\u2502   \u2502   \u251c\u2500\u2500 components.py   # Model components\n\u2502   \u2502   \u2514\u2500\u2500 s4.py           # S4 implementation\n\u2502   \u2514\u2500\u2500 utils/              # Utility functions\n\u2514\u2500\u2500 train.py                 # Training script\n</code></pre>"},{"location":"explanation/architecture/#key-classes","title":"Key Classes","text":""},{"location":"explanation/architecture/#componentregistry","title":"ComponentRegistry","text":"<ul> <li>Central registry for all components</li> <li>Handles component registration and retrieval</li> <li>Ensures type safety</li> </ul>"},{"location":"explanation/architecture/#basecomponent","title":"BaseComponent","text":"<ul> <li>Abstract base class for all components</li> <li>Handles configuration validation</li> <li>Defines common interface</li> </ul>"},{"location":"explanation/architecture/#basemodel","title":"BaseModel","text":"<ul> <li>Main model class</li> <li>Composes components based on configuration</li> <li>Handles training and inference</li> </ul>"},{"location":"explanation/architecture/#componentconfig","title":"ComponentConfig","text":"<ul> <li>Base configuration class</li> <li>Uses Pydantic for validation</li> <li>Integrates with Hydra configuration</li> </ul>"},{"location":"explanation/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"explanation/architecture/#component-design","title":"Component Design","text":"<ol> <li>Lazy Initialization</li> <li>Components are only initialized when needed</li> <li>Configuration is validated early</li> <li> <p>Resources are allocated efficiently</p> </li> <li> <p>Configuration Caching</p> </li> <li>Configurations are parsed once</li> <li>Common configurations are reused</li> <li> <p>Reduces memory overhead</p> </li> <li> <p>Dynamic Component Selection</p> </li> <li>Only required components are initialized</li> <li>Custom components can be more efficient</li> <li>Allows for hardware-specific optimizations</li> </ol>"},{"location":"explanation/architecture/#memory-efficiency","title":"Memory Efficiency","text":"<ol> <li>Batch Processing</li> <li>Dynamic batch sizes</li> <li>Gradient accumulation</li> <li> <p>Memory-efficient attention</p> </li> <li> <p>Model Optimization</p> </li> <li>Parameter sharing</li> <li>Quantization</li> <li>Pruning</li> </ol>"},{"location":"explanation/architecture/#training-speed","title":"Training Speed","text":"<ol> <li>Hardware Acceleration</li> <li>GPU support</li> <li>Mixed precision</li> <li> <p>Parallel processing</p> </li> <li> <p>Optimization</p> </li> <li>Efficient data loading</li> <li>Cached computations</li> <li>Optimized attention</li> </ol>"},{"location":"explanation/architecture/#related-resources","title":"Related Resources","text":"<ul> <li>SSL Methods - Self-supervised learning approaches</li> <li>Performance Considerations - Optimization and scaling</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"explanation/component-registry/","title":"Component Registry","text":"<p>This section explains the component registry pattern used in Tabular SSL and its benefits.</p>"},{"location":"explanation/component-registry/#overview","title":"Overview","text":"<p>The component registry is a core architectural pattern in Tabular SSL that enables a modular, extensible, and type-safe approach to building self-supervised learning models for tabular data.</p>"},{"location":"explanation/component-registry/#how-the-registry-works","title":"How the Registry Works","text":""},{"location":"explanation/component-registry/#registry-implementation","title":"Registry Implementation","text":"<p>The component registry is implemented as a class with static methods for registering and retrieving components:</p> <pre><code>class ComponentRegistry:\n    \"\"\"Registry for model components.\"\"\"\n\n    _components: ClassVar[Dict[str, Type['BaseComponent']]] = {}\n\n    @classmethod\n    def register(cls, name: str) -&gt; Type[T]:\n        \"\"\"Register a component class.\"\"\"\n        def decorator(component_cls: Type[T]) -&gt; Type[T]:\n            cls._components[name] = component_cls\n            return component_cls\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -&gt; Type['BaseComponent']:\n        \"\"\"Get a component class by name.\"\"\"\n        if name not in cls._components:\n            raise KeyError(f\"Component {name} not found in registry\")\n        return cls._components[name]\n\n    @classmethod\n    def list_components(cls) -&gt; Dict[str, Type['BaseComponent']]:\n        \"\"\"Get a dictionary of all registered components.\"\"\"\n        return cls._components.copy()\n</code></pre>"},{"location":"explanation/component-registry/#component-registration","title":"Component Registration","text":"<p>Components are registered using a decorator:</p> <pre><code>@ComponentRegistry.register(\"mlp_event_encoder\")\nclass MLPEventEncoder(EventEncoder):\n    def __init__(self, config: MLPConfig):\n        super().__init__(config)\n        # Implementation...\n</code></pre> <p>This decorator adds the component class to the registry with the specified name.</p>"},{"location":"explanation/component-registry/#component-configuration","title":"Component Configuration","text":"<p>Each component has a configuration class that inherits from <code>ComponentConfig</code>:</p> <pre><code>class MLPConfig(ComponentConfig):\n    \"\"\"Configuration for MLP-based components.\"\"\"\n\n    input_dim: int = Field(..., description=\"Input dimension\")\n    hidden_dims: List[int] = Field(..., description=\"Hidden dimensions\")\n    output_dim: int = Field(..., description=\"Output dimension\")\n    dropout: float = Field(0.1, description=\"Dropout rate\")\n    use_batch_norm: bool = Field(True, description=\"Whether to use batch normalization\")\n</code></pre> <p>The configuration class uses Pydantic for validation and includes fields specific to that component.</p>"},{"location":"explanation/component-registry/#component-instantiation","title":"Component Instantiation","text":"<p>Components are instantiated from their configuration:</p> <pre><code># Get component class\ncomponent_cls = ComponentRegistry.get(config.type)\n\n# Instantiate component\ncomponent = component_cls(config)\n</code></pre>"},{"location":"explanation/component-registry/#registry-benefits","title":"Registry Benefits","text":""},{"location":"explanation/component-registry/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>The registry pattern separates several concerns:</p> <ul> <li>Components: Focus on their specific functionality</li> <li>Registry: Handles component discovery and retrieval</li> <li>Configuration: Handles component parameters</li> <li>Factory: Handles component instantiation</li> </ul> <p>This separation makes the codebase easier to understand and modify.</p>"},{"location":"explanation/component-registry/#2-type-safety-and-validation","title":"2. Type Safety and Validation","text":"<p>The registry pattern enables several layers of validation:</p> <ul> <li>Component Type Checking: Ensuring that components implement the required interfaces</li> <li>Configuration Validation: Using Pydantic to validate component parameters</li> <li>Registry Existence Checking: Ensuring that requested components exist</li> </ul> <p>This helps catch configuration errors early.</p>"},{"location":"explanation/component-registry/#3-extensibility","title":"3. Extensibility","text":"<p>The registry pattern makes the codebase highly extensible:</p> <ul> <li>Add New Components: Without modifying existing code</li> <li>Override Existing Components: By registering a component with the same name</li> <li>User Extensions: Users can register their own components</li> </ul> <p>This allows for a plugin-like architecture.</p>"},{"location":"explanation/component-registry/#4-dynamic-component-loading","title":"4. Dynamic Component Loading","text":"<p>The registry pattern enables dynamic component loading:</p> <ul> <li>Runtime Component Selection: Components are loaded based on configuration</li> <li>Lazy Initialization: Components are only initialized when needed</li> <li>Conditional Components: Components can be conditionally included or excluded</li> </ul> <p>This flexibility is essential for a library that needs to support many different use cases.</p>"},{"location":"explanation/component-registry/#5-improved-testing","title":"5. Improved Testing","text":"<p>The registry pattern improves testability:</p> <ul> <li>Mock Components: Components can be replaced with mocks for testing</li> <li>Component Isolation: Components can be tested in isolation</li> <li>Configuration Testing: Configurations can be validated separately</li> </ul>"},{"location":"explanation/component-registry/#registry-and-hydra-integration","title":"Registry and Hydra Integration","text":"<p>The component registry integrates with Hydra's configuration system:</p>"},{"location":"explanation/component-registry/#from-hydra-configuration-to-component-configuration","title":"From Hydra Configuration to Component Configuration","text":"<pre><code>def from_hydra(cls, config: DictConfig) -&gt; \"ComponentConfig\":\n    \"\"\"Create a ComponentConfig from a Hydra config.\"\"\"\n    config_dict = OmegaConf.to_container(config, resolve=True)\n    return cls(**config_dict)\n</code></pre>"},{"location":"explanation/component-registry/#hydra-configuration-example","title":"Hydra Configuration Example","text":"<pre><code># configs/model/event_encoder/mlp.yaml\nname: mlp_encoder\ntype: mlp_event_encoder\ninput_dim: 64\nhidden_dims: [128, 256]\noutput_dim: 512\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"explanation/component-registry/#component-initialization-from-hydra","title":"Component Initialization from Hydra","text":"<pre><code># In the model class\ndef __init__(self, config: DictConfig):\n    super().__init__()\n    self.config = config\n\n    # Convert Hydra configs to ComponentConfigs\n    self.event_encoder_config = ComponentConfig.from_hydra(config.model.event_encoder)\n\n    # Initialize components\n    self.event_encoder = self._init_component(self.event_encoder_config)\n</code></pre>"},{"location":"explanation/component-registry/#component-types","title":"Component Types","text":"<p>The registry includes several component types:</p>"},{"location":"explanation/component-registry/#eventencoder","title":"EventEncoder","text":"<p>Base class for components that encode individual events or timesteps.</p> <pre><code>@ComponentRegistry.register(\"mlp_event_encoder\")\nclass MLPEventEncoder(EventEncoder):\n    \"\"\"MLP-based event encoder.\"\"\"\n</code></pre>"},{"location":"explanation/component-registry/#sequenceencoder","title":"SequenceEncoder","text":"<p>Base class for components that encode sequences of events.</p> <pre><code>@ComponentRegistry.register(\"transformer\")\nclass TransformerSequenceModel(SequenceEncoder):\n    \"\"\"Transformer sequence encoder.\"\"\"\n</code></pre>"},{"location":"explanation/component-registry/#embeddinglayer","title":"EmbeddingLayer","text":"<p>Base class for components that handle embedding of categorical features.</p> <pre><code>@ComponentRegistry.register(\"categorical_embedding\")\nclass CategoricalEmbedding(EmbeddingLayer):\n    \"\"\"Embedding layer for categorical variables.\"\"\"\n</code></pre>"},{"location":"explanation/component-registry/#projectionhead","title":"ProjectionHead","text":"<p>Base class for components that project encoded representations to a different space.</p> <pre><code>@ComponentRegistry.register(\"mlp_projection\")\nclass MLPProjectionHead(ProjectionHead):\n    \"\"\"MLP-based projection head.\"\"\"\n</code></pre>"},{"location":"explanation/component-registry/#predictionhead","title":"PredictionHead","text":"<p>Base class for components that generate predictions from encoded representations.</p> <pre><code>@ComponentRegistry.register(\"classification\")\nclass ClassificationHead(PredictionHead):\n    \"\"\"Classification head.\"\"\"\n</code></pre>"},{"location":"explanation/component-registry/#best-practices","title":"Best Practices","text":""},{"location":"explanation/component-registry/#when-to-register-components","title":"When to Register Components","text":"<p>Components should be registered when they:</p> <ol> <li>Provide Reusable Functionality: Will be used in multiple places</li> <li>Need Configuration: Have parameters that can be configured</li> <li>Represent Alternative Implementations: Are different ways to implement the same interface</li> </ol>"},{"location":"explanation/component-registry/#naming-components","title":"Naming Components","text":"<p>Component names should:</p> <ol> <li>Be Descriptive: Clearly indicate what the component does</li> <li>Use Consistent Naming: Follow a consistent pattern</li> <li>Avoid Collisions: Be unique within the registry</li> </ol>"},{"location":"explanation/component-registry/#documentation","title":"Documentation","text":"<p>Component documentation should include:</p> <ol> <li>Purpose: What the component is for</li> <li>Configuration: What configuration parameters are available</li> <li>Usage Examples: How to use the component</li> <li>Performance Considerations: Any performance implications</li> </ol>"},{"location":"explanation/component-registry/#examples","title":"Examples","text":""},{"location":"explanation/component-registry/#implementing-a-custom-component","title":"Implementing a Custom Component","text":"<pre><code>from tabular_ssl.models.base import EventEncoder, ComponentRegistry\nfrom tabular_ssl.models.components import MLPConfig\n\n@ComponentRegistry.register(\"custom_encoder\")\nclass CustomEncoder(EventEncoder):\n    def __init__(self, config: MLPConfig):\n        super().__init__(config)\n        self.layers = nn.ModuleList()\n\n        # Implementation...\n\n    def forward(self, x):\n        # Forward pass implementation...\n        return encoded\n</code></pre>"},{"location":"explanation/component-registry/#configuration-for-custom-component","title":"Configuration for Custom Component","text":"<pre><code># configs/model/event_encoder/custom.yaml\nname: custom_encoder\ntype: custom_encoder\ninput_dim: 64\nhidden_dims: [128, 64]\noutput_dim: 32\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"explanation/component-registry/#using-custom-component-in-experiment","title":"Using Custom Component in Experiment","text":"<pre><code># configs/experiment/custom_experiment.yaml\n# @package _global_\n\ndefaults:\n  - override /model/event_encoder: custom.yaml\n  - override /model/sequence_encoder: transformer.yaml\n  - _self_\n\n# Other experiment settings...\n</code></pre>"},{"location":"explanation/performance/","title":"Performance Considerations","text":"<p>This section covers performance optimization and scaling considerations for Tabular SSL.</p>"},{"location":"explanation/performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"explanation/performance/#batch-processing","title":"Batch Processing","text":"<ol> <li> <p>Dynamic Batch Sizes <pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    batch_size=32,  # Adjust based on available memory\n    gradient_accumulation_steps=4  # Accumulate gradients\n)\n</code></pre></p> </li> <li> <p>Memory-Efficient Attention <pre><code>model = TabularSSL(\n    input_dim=10,\n    attention_type='memory_efficient',  # Use memory-efficient attention\n    chunk_size=64  # Process attention in chunks\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#model-optimization","title":"Model Optimization","text":"<ol> <li> <p>Parameter Sharing <pre><code>model = TabularSSL(\n    input_dim=10,\n    share_parameters=True,  # Share parameters across layers\n    parameter_efficiency=True  # Use parameter-efficient methods\n)\n</code></pre></p> </li> <li> <p>Quantization <pre><code>from tabular_ssl.utils import quantize_model\n\n# Quantize model to reduce memory usage\nquantized_model = quantize_model(\n    model,\n    precision='int8'  # Use 8-bit quantization\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#training-speed","title":"Training Speed","text":""},{"location":"explanation/performance/#hardware-acceleration","title":"Hardware Acceleration","text":"<ol> <li> <p>GPU Support <pre><code>model = TabularSSL(\n    input_dim=10,\n    device='cuda',  # Use GPU\n    mixed_precision=True  # Enable mixed precision training\n)\n</code></pre></p> </li> <li> <p>Multi-GPU Training <pre><code>model = TabularSSL(\n    input_dim=10,\n    distributed=True,  # Enable distributed training\n    num_gpus=4  # Use 4 GPUs\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#optimization-techniques","title":"Optimization Techniques","text":"<ol> <li> <p>Efficient Data Loading <pre><code>from tabular_ssl.data import DataLoader\n\nloader = DataLoader(\n    num_workers=4,  # Use multiple workers\n    pin_memory=True,  # Pin memory for faster transfer\n    prefetch_factor=2  # Prefetch data\n)\n</code></pre></p> </li> <li> <p>Cached Computations <pre><code>model = TabularSSL(\n    input_dim=10,\n    cache_attention=True,  # Cache attention computations\n    cache_size=1000  # Cache size\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"explanation/performance/#data-scaling","title":"Data Scaling","text":"<ol> <li> <p>Large Datasets <pre><code>from tabular_ssl.data import StreamingDataLoader\n\n# Use streaming data loader for large datasets\nloader = StreamingDataLoader(\n    data_path='large_dataset.csv',\n    batch_size=32,\n    chunk_size=10000  # Process data in chunks\n)\n</code></pre></p> </li> <li> <p>Distributed Data Processing <pre><code>from tabular_ssl.data import DistributedDataLoader\n\n# Use distributed data loader\nloader = DistributedDataLoader(\n    data_path='large_dataset.csv',\n    num_workers=4,\n    world_size=4  # Number of processes\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#model-scaling","title":"Model Scaling","text":"<ol> <li> <p>Model Parallelism <pre><code>model = TabularSSL(\n    input_dim=10,\n    model_parallel=True,  # Enable model parallelism\n    num_devices=4  # Split model across 4 devices\n)\n</code></pre></p> </li> <li> <p>Pipeline Parallelism <pre><code>model = TabularSSL(\n    input_dim=10,\n    pipeline_parallel=True,  # Enable pipeline parallelism\n    num_stages=4  # Number of pipeline stages\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"explanation/performance/#metrics","title":"Metrics","text":"<ol> <li> <p>Training Metrics <pre><code>from tabular_ssl.utils import TrainingMonitor\n\nmonitor = TrainingMonitor(\n    metrics=['loss', 'accuracy', 'memory_usage'],\n    log_interval=100\n)\n</code></pre></p> </li> <li> <p>System Metrics <pre><code>from tabular_ssl.utils import SystemMonitor\n\nmonitor = SystemMonitor(\n    metrics=['gpu_usage', 'memory_usage', 'throughput'],\n    log_interval=1\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#profiling","title":"Profiling","text":"<ol> <li> <p>Model Profiling <pre><code>from tabular_ssl.utils import profile_model\n\n# Profile model performance\nprofile = profile_model(\n    model,\n    input_size=(32, 10),  # Batch size, input dimension\n    num_runs=100\n)\n</code></pre></p> </li> <li> <p>Memory Profiling <pre><code>from tabular_ssl.utils import profile_memory\n\n# Profile memory usage\nmemory_profile = profile_memory(\n    model,\n    input_size=(32, 10)\n)\n</code></pre></p> </li> </ol>"},{"location":"explanation/performance/#best-practices","title":"Best Practices","text":""},{"location":"explanation/performance/#memory-management","title":"Memory Management","text":"<ol> <li>Batch Size Selection</li> <li>Start with small batch sizes</li> <li>Gradually increase if memory allows</li> <li> <p>Use gradient accumulation for large batches</p> </li> <li> <p>Model Architecture</p> </li> <li>Use parameter-efficient architectures</li> <li>Implement memory-efficient attention</li> <li>Consider model quantization</li> </ol>"},{"location":"explanation/performance/#training-optimization","title":"Training Optimization","text":"<ol> <li>Hardware Utilization</li> <li>Use GPU acceleration</li> <li>Enable mixed precision training</li> <li> <p>Implement distributed training</p> </li> <li> <p>Data Processing</p> </li> <li>Use efficient data loaders</li> <li>Implement data prefetching</li> <li>Cache frequent computations</li> </ol>"},{"location":"explanation/performance/#related-resources","title":"Related Resources","text":"<ul> <li>Architecture Overview - System design details</li> <li>SSL Methods - Learning approaches</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"explanation/ssl-methods/","title":"Self-Supervised Learning Methods","text":"<p>This section explains the self-supervised learning methods implemented in Tabular SSL.</p>"},{"location":"explanation/ssl-methods/#overview","title":"Overview","text":"<p>Self-supervised learning (SSL) is a machine learning paradigm where models learn from unlabeled data by creating their own supervision signals. In Tabular SSL, we implement several SSL methods:</p> <ol> <li>Masked Feature Prediction</li> <li>Contrastive Learning</li> <li>Feature Reconstruction</li> </ol>"},{"location":"explanation/ssl-methods/#masked-feature-prediction","title":"Masked Feature Prediction","text":""},{"location":"explanation/ssl-methods/#how-it-works","title":"How It Works","text":"<ol> <li>Feature Masking</li> <li>Randomly mask a portion of features</li> <li>Use a masking ratio (default: 0.15)</li> <li> <p>Preserve feature relationships</p> </li> <li> <p>Prediction Task</p> </li> <li>Predict masked features</li> <li>Use surrounding features as context</li> <li>Learn feature dependencies</li> </ol>"},{"location":"explanation/ssl-methods/#implementation","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    mask_ratio=0.15  # 15% of features masked\n)\n\n# Train with masked feature prediction\nhistory = model.train(\n    data=train_data,\n    ssl_method='masked_prediction'\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#contrastive-learning","title":"Contrastive Learning","text":""},{"location":"explanation/ssl-methods/#how-it-works_1","title":"How It Works","text":"<ol> <li>Data Augmentation</li> <li>Create positive pairs</li> <li>Apply transformations</li> <li> <p>Generate negative samples</p> </li> <li> <p>Contrastive Loss</p> </li> <li>Maximize similarity of positive pairs</li> <li>Minimize similarity of negative pairs</li> <li>Learn robust representations</li> </ol>"},{"location":"explanation/ssl-methods/#implementation_1","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_method='contrastive'\n)\n\n# Train with contrastive learning\nhistory = model.train(\n    data=train_data,\n    temperature=0.07,  # Temperature parameter\n    queue_size=65536   # Size of memory queue\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#feature-reconstruction","title":"Feature Reconstruction","text":""},{"location":"explanation/ssl-methods/#how-it-works_2","title":"How It Works","text":"<ol> <li>Autoencoder Architecture</li> <li>Encode input features</li> <li>Decode to reconstruct</li> <li> <p>Learn feature representations</p> </li> <li> <p>Reconstruction Loss</p> </li> <li>Minimize reconstruction error</li> <li>Learn feature relationships</li> <li>Capture data structure</li> </ol>"},{"location":"explanation/ssl-methods/#implementation_2","title":"Implementation","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_method='reconstruction'\n)\n\n# Train with feature reconstruction\nhistory = model.train(\n    data=train_data,\n    reconstruction_weight=1.0\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#combining-methods","title":"Combining Methods","text":""},{"location":"explanation/ssl-methods/#multi-task-learning","title":"Multi-Task Learning","text":"<pre><code>from tabular_ssl import TabularSSL\n\nmodel = TabularSSL(\n    input_dim=10,\n    ssl_methods=['masked_prediction', 'contrastive']\n)\n\n# Train with multiple SSL methods\nhistory = model.train(\n    data=train_data,\n    method_weights={\n        'masked_prediction': 0.5,\n        'contrastive': 0.5\n    }\n)\n</code></pre>"},{"location":"explanation/ssl-methods/#method-selection","title":"Method Selection","text":""},{"location":"explanation/ssl-methods/#when-to-use-each-method","title":"When to Use Each Method","text":"<ol> <li>Masked Feature Prediction</li> <li>When feature relationships are important</li> <li>For structured tabular data</li> <li> <p>When interpretability is needed</p> </li> <li> <p>Contrastive Learning</p> </li> <li>For robust representations</li> <li>When data augmentation is possible</li> <li> <p>For transfer learning</p> </li> <li> <p>Feature Reconstruction</p> </li> <li>For simple feature learning</li> <li>When computational efficiency is important</li> <li>For basic representation learning</li> </ol>"},{"location":"explanation/ssl-methods/#best-practices","title":"Best Practices","text":""},{"location":"explanation/ssl-methods/#method-selection_1","title":"Method Selection","text":"<ol> <li>Data Characteristics</li> <li>Consider data structure</li> <li>Evaluate feature relationships</li> <li> <p>Assess data quality</p> </li> <li> <p>Task Requirements</p> </li> <li>Define learning objectives</li> <li>Consider downstream tasks</li> <li> <p>Evaluate computational needs</p> </li> <li> <p>Resource Constraints</p> </li> <li>Consider memory usage</li> <li>Evaluate training time</li> <li>Assess hardware requirements</li> </ol>"},{"location":"explanation/ssl-methods/#implementation-tips","title":"Implementation Tips","text":"<ol> <li>Hyperparameter Tuning</li> <li>Masking ratio</li> <li>Temperature parameter</li> <li> <p>Loss weights</p> </li> <li> <p>Training Strategy</p> </li> <li>Learning rate scheduling</li> <li>Batch size selection</li> <li> <p>Early stopping</p> </li> <li> <p>Evaluation</p> </li> <li>Monitor SSL metrics</li> <li>Evaluate downstream performance</li> <li>Compare methods</li> </ol>"},{"location":"explanation/ssl-methods/#related-resources","title":"Related Resources","text":"<ul> <li>Architecture Overview - System design details</li> <li>Performance Considerations - Optimization guide</li> <li>API Reference - Technical documentation </li> </ul>"},{"location":"how-to-guides/","title":"How-to Guides","text":"<p>This section contains practical guides for common tasks and specific use cases with Tabular SSL.</p>"},{"location":"how-to-guides/#available-guides","title":"Available Guides","text":"<ul> <li>Data Preparation - Learn how to prepare your data for Tabular SSL</li> <li>Model Training - Best practices for training models</li> <li>Evaluation - How to evaluate and interpret model results</li> </ul>"},{"location":"how-to-guides/#common-tasks","title":"Common Tasks","text":""},{"location":"how-to-guides/#data-preparation","title":"Data Preparation","text":"<ul> <li>Loading and preprocessing data</li> <li>Handling categorical variables</li> <li>Feature scaling and normalization</li> <li>Dealing with missing values</li> </ul>"},{"location":"how-to-guides/#model-training","title":"Model Training","text":"<ul> <li>Setting up training configurations</li> <li>Monitoring training progress</li> <li>Saving and loading models</li> <li>Hyperparameter tuning</li> </ul>"},{"location":"how-to-guides/#evaluation","title":"Evaluation","text":"<ul> <li>Computing performance metrics</li> <li>Visualizing results</li> <li>Model interpretation</li> <li>Error analysis</li> </ul>"},{"location":"how-to-guides/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>Tutorials - Step-by-step learning guides</li> <li>Explanation - Background information </li> </ul>"},{"location":"how-to-guides/configuring-experiments/","title":"Configuring Experiments","text":"<p>This guide explains how to configure and run experiments using Hydra in Tabular SSL.</p>"},{"location":"how-to-guides/configuring-experiments/#introduction","title":"Introduction","text":"<p>Tabular SSL uses Hydra for configuration management, which enables hierarchical configuration composition, command-line overrides, and experiment tracking. This guide will show you how to:</p> <ol> <li>Use the configuration structure</li> <li>Create and run experiments</li> <li>Override default parameters</li> <li>Run parameter sweeps</li> </ol>"},{"location":"how-to-guides/configuring-experiments/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration files are organized in a hierarchical structure:</p> <pre><code>configs/\n\u251c\u2500\u2500 config.yaml                # Main configuration\n\u251c\u2500\u2500 model/                     # Model configurations\n\u2502   \u251c\u2500\u2500 default.yaml          # Default model config\n\u2502   \u251c\u2500\u2500 event_encoder/        # Event encoder configs\n\u2502   \u251c\u2500\u2500 sequence_encoder/     # Sequence encoder configs\n\u2502   \u251c\u2500\u2500 embedding/            # Embedding configs\n\u2502   \u251c\u2500\u2500 projection_head/      # Projection head configs\n\u2502   \u2514\u2500\u2500 prediction_head/      # Prediction head configs\n\u251c\u2500\u2500 data/                     # Data configurations\n\u251c\u2500\u2500 trainer/                  # Training configurations\n\u251c\u2500\u2500 callbacks/                # Callback configurations\n\u251c\u2500\u2500 logger/                   # Logger configurations\n\u251c\u2500\u2500 experiment/               # Experiment configurations\n\u251c\u2500\u2500 hydra/                    # Hydra-specific configurations\n\u2514\u2500\u2500 paths/                    # Path configurations\n</code></pre>"},{"location":"how-to-guides/configuring-experiments/#basic-usage","title":"Basic Usage","text":""},{"location":"how-to-guides/configuring-experiments/#running-with-default-configuration","title":"Running with Default Configuration","text":"<p>To run with the default configuration:</p> <pre><code>python src/train.py\n</code></pre> <p>This will use the configuration in <code>configs/config.yaml</code>, which composes configurations from the other directories.</p>"},{"location":"how-to-guides/configuring-experiments/#overriding-parameters","title":"Overriding Parameters","text":"<p>You can override any parameter using the command line:</p> <pre><code>python src/train.py model.optimizer.lr=0.001 trainer.max_epochs=50\n</code></pre> <p>This will override the learning rate and the maximum number of epochs while using the default values for all other parameters.</p>"},{"location":"how-to-guides/configuring-experiments/#using-a-specific-configuration","title":"Using a Specific Configuration","text":"<p>You can use a specific configuration for a component:</p> <pre><code>python src/train.py model/event_encoder=mlp model/sequence_encoder=transformer\n</code></pre> <p>This will use the MLP event encoder and Transformer sequence encoder configurations.</p>"},{"location":"how-to-guides/configuring-experiments/#creating-experiments","title":"Creating Experiments","text":""},{"location":"how-to-guides/configuring-experiments/#experiment-configuration-files","title":"Experiment Configuration Files","text":"<p>Experiment configuration files are stored in <code>configs/experiment/</code> and provide a way to group parameter overrides.</p> <p>Here's an example experiment configuration file:</p> <pre><code># configs/experiment/transformer_ssl.yaml\n# @package _global_\n\ndefaults:\n  - override /model/event_encoder: mlp.yaml\n  - override /model/sequence_encoder: transformer.yaml\n  - override /trainer: default.yaml\n  - override /model: default.yaml\n  - override /callbacks: default.yaml\n  - _self_\n\ntags: [\"transformer\", \"ssl\"]\n\nseed: 12345\n\ntrainer:\n  max_epochs: 100\n  gradient_clip_val: 0.5\n\nmodel:\n  optimizer:\n    lr: 1.0e-4\n    weight_decay: 0.01\n</code></pre> <p>Key things to note:</p> <ol> <li><code># @package _global_</code>: This indicates that the configuration should be merged at the global level</li> <li><code>defaults</code>: Specifies which configurations to use as defaults</li> <li><code>override /path/to/config</code>: Overrides a specific configuration</li> <li><code>_self_</code>: Ensures that the current file's configurations are applied after all others</li> </ol>"},{"location":"how-to-guides/configuring-experiments/#running-an-experiment","title":"Running an Experiment","text":"<p>To run an experiment:</p> <pre><code>python src/train.py experiment=transformer_ssl\n</code></pre> <p>This will use the configuration defined in <code>configs/experiment/transformer_ssl.yaml</code>.</p>"},{"location":"how-to-guides/configuring-experiments/#extending-an-experiment","title":"Extending an Experiment","text":"<p>You can extend an experiment by overriding its parameters:</p> <pre><code>python src/train.py experiment=transformer_ssl trainer.max_epochs=200\n</code></pre> <p>This will use the transformer_ssl experiment configuration with the maximum epochs set to 200.</p>"},{"location":"how-to-guides/configuring-experiments/#debugging","title":"Debugging","text":""},{"location":"how-to-guides/configuring-experiments/#debug-mode","title":"Debug Mode","text":"<p>You can run in debug mode to speed up debugging:</p> <pre><code>python src/train.py debug=true\n</code></pre> <p>This will typically: - Run on a smaller dataset - Use fewer epochs - Disable certain features like logging</p>"},{"location":"how-to-guides/configuring-experiments/#experiment-tracking","title":"Experiment Tracking","text":""},{"location":"how-to-guides/configuring-experiments/#logging-and-output","title":"Logging and Output","text":"<p>When you run an experiment, Hydra creates an output directory for that run:</p> <pre><code>outputs/\n\u2514\u2500\u2500 2023-06-15/\n    \u2514\u2500\u2500 12-34-56/\n        \u251c\u2500\u2500 .hydra/\n        \u2502   \u251c\u2500\u2500 config.yaml\n        \u2502   \u251c\u2500\u2500 hydra.yaml\n        \u2502   \u2514\u2500\u2500 overrides.yaml\n        \u251c\u2500\u2500 checkpoints/\n        \u2514\u2500\u2500 logs/\n</code></pre> <p>The <code>.hydra/</code> directory contains the full configuration that was used for the run.</p>"},{"location":"how-to-guides/configuring-experiments/#tags","title":"Tags","text":"<p>You can add tags to your experiments:</p> <pre><code># configs/experiment/transformer_ssl.yaml\ntags: [\"transformer\", \"ssl\"]\n</code></pre> <p>Or via the command line:</p> <pre><code>python src/train.py tags=\"[transformer, ssl]\"\n</code></pre> <p>These tags can be used for filtering and grouping experiments.</p>"},{"location":"how-to-guides/configuring-experiments/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>Hydra allows you to perform parameter sweeps by specifying multiple values for a parameter.</p>"},{"location":"how-to-guides/configuring-experiments/#basic-sweep","title":"Basic Sweep","text":"<pre><code>python src/train.py -m model.optimizer.lr=1e-3,1e-4,1e-5\n</code></pre> <p>This will run three experiments with different learning rates.</p>"},{"location":"how-to-guides/configuring-experiments/#multi-parameter-sweep","title":"Multi-Parameter Sweep","text":"<pre><code>python src/train.py -m model.optimizer.lr=1e-3,1e-4 model.optimizer.weight_decay=0.01,0.001\n</code></pre> <p>This will run 4 experiments (2 learning rates \u00d7 2 weight decay values).</p>"},{"location":"how-to-guides/configuring-experiments/#sweep-with-experiment","title":"Sweep with Experiment","text":"<pre><code>python src/train.py -m experiment=transformer_ssl,s4_ssl\n</code></pre> <p>This will run both the transformer_ssl and s4_ssl experiments.</p>"},{"location":"how-to-guides/configuring-experiments/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"how-to-guides/configuring-experiments/#using-environment-variables","title":"Using Environment Variables","text":"<p>You can use environment variables in your configurations:</p> <pre><code>data:\n  path: ${oc.env:DATA_PATH,/default/path}\n</code></pre> <p>This will use the <code>DATA_PATH</code> environment variable if it exists, or fall back to <code>/default/path</code>.</p>"},{"location":"how-to-guides/configuring-experiments/#using-interpolation","title":"Using Interpolation","text":"<p>You can reference other configuration values:</p> <pre><code>model:\n  input_dim: 64\n  hidden_dim: ${model.input_dim}  # References input_dim\n</code></pre>"},{"location":"how-to-guides/configuring-experiments/#dynamic-default-values","title":"Dynamic Default Values","text":"<p>You can compute default values based on other parameters:</p> <pre><code>model:\n  input_dim: 64\n  hidden_dim: ${eval:2 * ${model.input_dim}}  # Dynamic computation\n</code></pre>"},{"location":"how-to-guides/configuring-experiments/#best-practices","title":"Best Practices","text":""},{"location":"how-to-guides/configuring-experiments/#naming-conventions","title":"Naming Conventions","text":"<ol> <li>Use descriptive names for experiment files</li> <li>Group related parameters together</li> <li>Use consistent naming across configurations</li> </ol>"},{"location":"how-to-guides/configuring-experiments/#configuration-structure_1","title":"Configuration Structure","text":"<ol> <li>Keep configuration files small and focused</li> <li>Use defaults for common parameters</li> <li>Override only what's necessary</li> </ol>"},{"location":"how-to-guides/configuring-experiments/#experiment-management","title":"Experiment Management","text":"<ol> <li>Use meaningful tags for experiments</li> <li>Add a brief description in the experiment file</li> <li>Document key parameter choices</li> </ol>"},{"location":"how-to-guides/configuring-experiments/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Start with an existing experiment: <code>python src/train.py experiment=transformer_ssl</code></li> <li>Make modifications via the command line: <code>python src/train.py experiment=transformer_ssl model.optimizer.lr=1e-5</code></li> <li>If the modifications work well, create a new experiment file</li> <li>Run parameter sweeps to find optimal values: <code>python src/train.py -m experiment=my_new_experiment model.optimizer.lr=1e-3,1e-4,1e-5</code></li> </ol>"},{"location":"how-to-guides/configuring-experiments/#conclusion","title":"Conclusion","text":"<p>Hydra provides a powerful way to configure and track experiments in Tabular SSL. By using experiment configuration files, command-line overrides, and parameter sweeps, you can efficiently explore the parameter space and find the best configurations for your specific task. </p>"},{"location":"how-to-guides/data-preparation/","title":"Data Preparation Guide","text":"<p>This guide covers best practices for preparing your data for use with Tabular SSL.</p>"},{"location":"how-to-guides/data-preparation/#loading-data","title":"Loading Data","text":""},{"location":"how-to-guides/data-preparation/#from-csv-files","title":"From CSV Files","text":"<pre><code>from tabular_ssl.data import DataLoader\n\n# Initialize the data loader\ndata_loader = DataLoader()\n\n# Load data from CSV\ndata = data_loader.load_data('path/to/your/data.csv')\n</code></pre>"},{"location":"how-to-guides/data-preparation/#from-pandas-dataframe","title":"From Pandas DataFrame","text":"<pre><code>import pandas as pd\n\n# Create or load your DataFrame\ndf = pd.DataFrame({\n    'numeric_col': [1, 2, 3],\n    'categorical_col': ['A', 'B', 'A']\n})\n\n# Use the data loader\ndata_loader = DataLoader()\nprocessed_data = data_loader.preprocess(df)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#handling-different-data-types","title":"Handling Different Data Types","text":""},{"location":"how-to-guides/data-preparation/#categorical-variables","title":"Categorical Variables","text":"<pre><code># Specify categorical columns\ncategorical_cols = ['category1', 'category2']\nprocessed_data = data_loader.preprocess(\n    data,\n    categorical_cols=categorical_cols\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#numerical-variables","title":"Numerical Variables","text":"<pre><code># Numerical columns are automatically detected\n# You can specify scaling options\nprocessed_data = data_loader.preprocess(\n    data,\n    scale_numerical=True,  # Enable scaling\n    scaler='standard'      # Use standard scaler\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#dealing-with-missing-values","title":"Dealing with Missing Values","text":""},{"location":"how-to-guides/data-preparation/#automatic-handling","title":"Automatic Handling","text":"<pre><code># The data loader automatically handles missing values\nprocessed_data = data_loader.preprocess(\n    data,\n    handle_missing=True,  # Enable missing value handling\n    missing_strategy='mean'  # Use mean imputation\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#manual-handling","title":"Manual Handling","text":"<pre><code>import pandas as pd\nimport numpy as np\n\n# Fill missing values\ndata = data.fillna({\n    'numeric_col': data['numeric_col'].mean(),\n    'categorical_col': data['categorical_col'].mode()[0]\n})\n</code></pre>"},{"location":"how-to-guides/data-preparation/#feature-engineering","title":"Feature Engineering","text":""},{"location":"how-to-guides/data-preparation/#creating-new-features","title":"Creating New Features","text":"<pre><code># Add interaction terms\ndata['interaction'] = data['feature1'] * data['feature2']\n\n# Add polynomial features\ndata['feature1_squared'] = data['feature1'] ** 2\n</code></pre>"},{"location":"how-to-guides/data-preparation/#feature-selection","title":"Feature Selection","text":"<pre><code>from tabular_ssl.utils import select_features\n\n# Select features based on importance\nselected_features = select_features(\n    data,\n    target_col='target',\n    method='importance',\n    threshold=0.01\n)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#data-validation","title":"Data Validation","text":""},{"location":"how-to-guides/data-preparation/#checking-data-quality","title":"Checking Data Quality","text":"<pre><code>from tabular_ssl.utils import validate_data\n\n# Validate data before processing\nvalidation_results = validate_data(data)\nprint(validation_results)\n</code></pre>"},{"location":"how-to-guides/data-preparation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<ol> <li> <p>Inconsistent Data Types <pre><code># Convert columns to correct types\ndata['numeric_col'] = pd.to_numeric(data['numeric_col'])\ndata['categorical_col'] = data['categorical_col'].astype('category')\n</code></pre></p> </li> <li> <p>Outliers <pre><code># Remove outliers\ndata = data[data['numeric_col'].between(\n    data['numeric_col'].quantile(0.01),\n    data['numeric_col'].quantile(0.99)\n)]\n</code></pre></p> </li> </ol>"},{"location":"how-to-guides/data-preparation/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate your data before processing</li> <li>Handle missing values appropriately for your use case</li> <li>Scale numerical features when necessary</li> <li>Encode categorical variables properly</li> <li>Check for and handle outliers</li> <li>Document your preprocessing steps</li> </ol>"},{"location":"how-to-guides/data-preparation/#related-resources","title":"Related Resources","text":"<ul> <li>Model Training - Next steps after data preparation</li> <li>API Reference - Detailed API documentation</li> <li>Tutorials - Step-by-step guides </li> </ul>"},{"location":"how-to-guides/evaluation/","title":"Model Evaluation Guide","text":"<p>This guide covers how to evaluate and interpret your Tabular SSL models.</p>"},{"location":"how-to-guides/evaluation/#basic-evaluation","title":"Basic Evaluation","text":""},{"location":"how-to-guides/evaluation/#computing-metrics","title":"Computing Metrics","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\n# Evaluate model performance\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\nprint(metrics)\n</code></pre>"},{"location":"how-to-guides/evaluation/#cross-validation","title":"Cross-Validation","text":"<pre><code>from tabular_ssl.utils import cross_validate\n\n# Perform k-fold cross-validation\ncv_results = cross_validate(\n    model,\n    data,\n    n_splits=5,\n    metrics=['accuracy', 'f1']\n)\nprint(cv_results)\n</code></pre>"},{"location":"how-to-guides/evaluation/#advanced-evaluation","title":"Advanced Evaluation","text":""},{"location":"how-to-guides/evaluation/#custom-metrics","title":"Custom Metrics","text":"<pre><code>from tabular_ssl.utils import CustomMetric\n\n# Define custom metric\ndef custom_metric(y_true, y_pred):\n    # Your custom metric implementation\n    return score\n\n# Evaluate with custom metric\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', CustomMetric(custom_metric)]\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#model-comparison","title":"Model Comparison","text":"<pre><code>from tabular_ssl.utils import compare_models\n\n# Compare multiple models\ncomparison = compare_models(\n    models=[model1, model2, model3],\n    test_data=test_data,\n    metrics=['accuracy', 'f1']\n)\nprint(comparison)\n</code></pre>"},{"location":"how-to-guides/evaluation/#visualization","title":"Visualization","text":""},{"location":"how-to-guides/evaluation/#training-history","title":"Training History","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\n# Plot training metrics\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#performance-plots","title":"Performance Plots","text":"<pre><code>from tabular_ssl.utils import plot_performance\n\n# Plot various performance metrics\nfig = plot_performance(\n    model,\n    test_data,\n    plot_types=['confusion_matrix', 'roc_curve', 'precision_recall']\n)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#model-interpretation","title":"Model Interpretation","text":""},{"location":"how-to-guides/evaluation/#feature-importance","title":"Feature Importance","text":"<pre><code>from tabular_ssl.utils import get_feature_importance\n\n# Get feature importance scores\nimportance = get_feature_importance(model, test_data)\nprint(importance)\n</code></pre>"},{"location":"how-to-guides/evaluation/#shap-values","title":"SHAP Values","text":"<pre><code>from tabular_ssl.utils import get_shap_values\n\n# Compute SHAP values\nshap_values = get_shap_values(model, test_data)\n\n# Plot SHAP summary\nplot_shap_summary(shap_values, test_data)\n</code></pre>"},{"location":"how-to-guides/evaluation/#error-analysis","title":"Error Analysis","text":""},{"location":"how-to-guides/evaluation/#error-distribution","title":"Error Distribution","text":"<pre><code>from tabular_ssl.utils import analyze_errors\n\n# Analyze prediction errors\nerror_analysis = analyze_errors(\n    model,\n    test_data,\n    analysis_types=['distribution', 'correlation']\n)\nprint(error_analysis)\n</code></pre>"},{"location":"how-to-guides/evaluation/#error-visualization","title":"Error Visualization","text":"<pre><code>from tabular_ssl.utils import plot_errors\n\n# Plot error analysis\nfig = plot_errors(\n    model,\n    test_data,\n    plot_types=['residuals', 'error_distribution']\n)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/evaluation/#best-practices","title":"Best Practices","text":"<ol> <li>Use multiple evaluation metrics</li> <li>Perform cross-validation for robust results</li> <li>Compare against baseline models</li> <li>Analyze error patterns</li> <li>Visualize results for better understanding</li> <li>Consider domain-specific metrics</li> <li>Document evaluation methodology</li> <li>Validate results with statistical tests</li> </ol>"},{"location":"how-to-guides/evaluation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"how-to-guides/evaluation/#unbalanced-data","title":"Unbalanced Data","text":"<pre><code>from tabular_ssl.utils import balanced_metrics\n\n# Use balanced metrics\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['balanced_accuracy', 'f1']\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#small-test-sets","title":"Small Test Sets","text":"<pre><code># Use bootstrapping for small test sets\nfrom tabular_ssl.utils import bootstrap_evaluation\n\nresults = bootstrap_evaluation(\n    model,\n    test_data,\n    n_bootstrap=1000,\n    metrics=['accuracy', 'f1']\n)\n</code></pre>"},{"location":"how-to-guides/evaluation/#related-resources","title":"Related Resources","text":"<ul> <li>Model Training - Training your model</li> <li>Data Preparation - Preparing your data</li> <li>API Reference - Detailed API documentation </li> </ul>"},{"location":"how-to-guides/model-training/","title":"Model Training Guide","text":"<p>This guide covers best practices for training models with Tabular SSL.</p>"},{"location":"how-to-guides/model-training/#basic-training","title":"Basic Training","text":""},{"location":"how-to-guides/model-training/#simple-training-loop","title":"Simple Training Loop","text":"<pre><code>from tabular_ssl import TabularSSL\n\n# Initialize model\nmodel = TabularSSL(input_dim=10)\n\n# Train model\nhistory = model.train(\n    data=train_data,\n    batch_size=32,\n    epochs=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#training-with-validation","title":"Training with Validation","text":"<pre><code># Split data into train and validation sets\nfrom sklearn.model_selection import train_test_split\n\ntrain_data, val_data = train_test_split(\n    data,\n    test_size=0.2,\n    random_state=42\n)\n\n# Train with validation\nhistory = model.train(\n    data=train_data,\n    validation_data=val_data,\n    batch_size=32,\n    epochs=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#advanced-training","title":"Advanced Training","text":""},{"location":"how-to-guides/model-training/#custom-training-configuration","title":"Custom Training Configuration","text":"<pre><code>history = model.train(\n    data=train_data,\n    batch_size=64,\n    epochs=200,\n    learning_rate=1e-4,\n    weight_decay=1e-5,\n    early_stopping=True,\n    patience=10,\n    min_delta=0.001\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#learning-rate-scheduling","title":"Learning Rate Scheduling","text":"<pre><code>from tabular_ssl.utils import get_lr_scheduler\n\n# Create learning rate scheduler\nlr_scheduler = get_lr_scheduler(\n    initial_lr=1e-3,\n    scheduler_type='cosine',\n    warmup_epochs=5\n)\n\n# Train with scheduler\nhistory = model.train(\n    data=train_data,\n    learning_rate=1e-3,\n    lr_scheduler=lr_scheduler\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#monitoring-training","title":"Monitoring Training","text":""},{"location":"how-to-guides/model-training/#logging-metrics","title":"Logging Metrics","text":"<pre><code>from tabular_ssl.utils import TrainingLogger\n\n# Initialize logger\nlogger = TrainingLogger(log_dir='logs')\n\n# Train with logging\nhistory = model.train(\n    data=train_data,\n    logger=logger,\n    log_interval=100\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#visualizing-progress","title":"Visualizing Progress","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\n# Plot training metrics\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"how-to-guides/model-training/#model-checkpointing","title":"Model Checkpointing","text":""},{"location":"how-to-guides/model-training/#saving-checkpoints","title":"Saving Checkpoints","text":"<pre><code># Save model checkpoints\nhistory = model.train(\n    data=train_data,\n    save_dir='checkpoints',\n    save_best_only=True,\n    save_frequency=5\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#loading-checkpoints","title":"Loading Checkpoints","text":"<pre><code># Load best model\nmodel = TabularSSL.load('checkpoints/best_model.pt')\n\n# Load specific checkpoint\nmodel = TabularSSL.load('checkpoints/model_epoch_50.pt')\n</code></pre>"},{"location":"how-to-guides/model-training/#hyperparameter-tuning","title":"Hyperparameter Tuning","text":""},{"location":"how-to-guides/model-training/#grid-search","title":"Grid Search","text":"<pre><code>from tabular_ssl.utils import grid_search\n\n# Define parameter grid\nparam_grid = {\n    'hidden_dim': [128, 256, 512],\n    'num_layers': [2, 4, 6],\n    'dropout': [0.1, 0.2, 0.3]\n}\n\n# Perform grid search\nbest_params = grid_search(\n    model_class=TabularSSL,\n    param_grid=param_grid,\n    train_data=train_data,\n    val_data=val_data\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#random-search","title":"Random Search","text":"<pre><code>from tabular_ssl.utils import random_search\n\n# Define parameter distributions\nparam_distributions = {\n    'hidden_dim': [128, 256, 512],\n    'num_layers': [2, 4, 6],\n    'dropout': [0.1, 0.2, 0.3]\n}\n\n# Perform random search\nbest_params = random_search(\n    model_class=TabularSSL,\n    param_distributions=param_distributions,\n    train_data=train_data,\n    val_data=val_data,\n    n_iter=10\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#best-practices","title":"Best Practices","text":"<ol> <li>Always use validation data during training</li> <li>Implement early stopping to prevent overfitting</li> <li>Use learning rate scheduling for better convergence</li> <li>Monitor training metrics regularly</li> <li>Save model checkpoints</li> <li>Experiment with different hyperparameters</li> <li>Use appropriate batch sizes for your data</li> <li>Normalize your data before training</li> </ol>"},{"location":"how-to-guides/model-training/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"how-to-guides/model-training/#overfitting","title":"Overfitting","text":"<pre><code># Increase dropout\nmodel = TabularSSL(\n    input_dim=10,\n    dropout=0.3  # Increased from default\n)\n\n# Add regularization\nhistory = model.train(\n    data=train_data,\n    weight_decay=1e-4\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#underfitting","title":"Underfitting","text":"<pre><code># Increase model capacity\nmodel = TabularSSL(\n    input_dim=10,\n    hidden_dim=512,  # Increased from default\n    num_layers=6     # Increased from default\n)\n\n# Train for more epochs\nhistory = model.train(\n    data=train_data,\n    epochs=300  # Increased from default\n)\n</code></pre>"},{"location":"how-to-guides/model-training/#related-resources","title":"Related Resources","text":"<ul> <li>Data Preparation - Preparing your data for training</li> <li>Evaluation - Evaluating your trained model</li> <li>API Reference - Detailed API documentation </li> </ul>"},{"location":"reference/","title":"Reference Documentation","text":"<p>This section provides detailed technical documentation for all components of the Tabular SSL library.</p>"},{"location":"reference/#available-references","title":"Available References","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Models - Model architectures and configurations</li> <li>Data Utilities - Data loading and preprocessing utilities</li> <li>Utility Functions - Helper functions and tools</li> </ul>"},{"location":"reference/#quick-reference","title":"Quick Reference","text":""},{"location":"reference/#main-classes","title":"Main Classes","text":"<pre><code>from tabular_ssl import TabularSSL\nfrom tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/#common-functions","title":"Common Functions","text":"<pre><code>from tabular_ssl.utils import evaluate_model, plot_training_history\n</code></pre>"},{"location":"reference/#module-structure","title":"Module Structure","text":"<ul> <li><code>tabular_ssl/</code> - Main package</li> <li><code>models/</code> - Model implementations</li> <li><code>data/</code> - Data handling utilities</li> <li><code>utils/</code> - Helper functions</li> </ul>"},{"location":"reference/#related-resources","title":"Related Resources","text":"<ul> <li>Tutorials - Step-by-step guides</li> <li>How-to Guides - Practical solutions</li> <li>Explanation - Background information </li> </ul>"},{"location":"reference/api/","title":"API Reference","text":"<p>This section provides detailed technical documentation for all public APIs in the Tabular SSL library.</p>"},{"location":"reference/api/#models","title":"Models","text":""},{"location":"reference/api/#tabularssl","title":"TabularSSL","text":"<p>The main class for self-supervised learning on tabular data.</p> <pre><code>from tabular_ssl import TabularSSL\n</code></pre>"},{"location":"reference/api/#parameters","title":"Parameters","text":"<ul> <li><code>input_dim</code> (int): Dimension of input features</li> <li><code>hidden_dim</code> (int, optional): Dimension of hidden layers. Defaults to 256.</li> <li><code>num_layers</code> (int, optional): Number of transformer layers. Defaults to 4.</li> <li><code>num_heads</code> (int, optional): Number of attention heads. Defaults to 4.</li> <li><code>dropout</code> (float, optional): Dropout rate. Defaults to 0.1.</li> <li><code>mask_ratio</code> (float, optional): Ratio of features to mask during training. Defaults to 0.15.</li> </ul>"},{"location":"reference/api/#methods","title":"Methods","text":""},{"location":"reference/api/#traindata-batch_size32-epochs100-learning_rate1e-4","title":"<code>train(data, batch_size=32, epochs=100, learning_rate=1e-4)</code>","text":"<p>Train the model using self-supervised learning.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>batch_size</code> (int): Batch size for training - <code>epochs</code> (int): Number of training epochs - <code>learning_rate</code> (float): Learning rate</p> <p>Returns: - <code>dict</code>: Training history</p>"},{"location":"reference/api/#predictdata","title":"<code>predict(data)</code>","text":"<p>Make predictions on new data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data</p> <p>Returns: - <code>np.ndarray</code>: Model predictions</p>"},{"location":"reference/api/#data-utilities","title":"Data Utilities","text":""},{"location":"reference/api/#dataloader","title":"DataLoader","text":"<p>Utility class for loading and preprocessing tabular data.</p> <pre><code>from tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/api/#methods_1","title":"Methods","text":""},{"location":"reference/api/#load_datafile_path-target_colnone","title":"<code>load_data(file_path, target_col=None)</code>","text":"<p>Load data from a file.</p> <p>Parameters: - <code>file_path</code> (str): Path to the data file - <code>target_col</code> (str, optional): Name of the target column</p> <p>Returns: - <code>pd.DataFrame</code>: Loaded data</p>"},{"location":"reference/api/#preprocessdata-categorical_colsnone","title":"<code>preprocess(data, categorical_cols=None)</code>","text":"<p>Preprocess the data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>categorical_cols</code> (list, optional): List of categorical column names</p> <p>Returns: - <code>pd.DataFrame</code>: Preprocessed data</p>"},{"location":"reference/api/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/api/#evaluation","title":"Evaluation","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n</code></pre>"},{"location":"reference/api/#evaluate_modelmodel-test_data-metricsaccuracy-f1","title":"<code>evaluate_model(model, test_data, metrics=['accuracy', 'f1'])</code>","text":"<p>Evaluate model performance.</p> <p>Parameters: - <code>model</code>: Trained model - <code>test_data</code> (pd.DataFrame): Test data - <code>metrics</code> (list): List of metrics to compute</p> <p>Returns: - <code>dict</code>: Dictionary of metric scores</p>"},{"location":"reference/api/#visualization","title":"Visualization","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n</code></pre>"},{"location":"reference/api/#plot_training_historyhistory","title":"<code>plot_training_history(history)</code>","text":"<p>Plot training history.</p> <p>Parameters: - <code>history</code> (dict): Training history dictionary</p> <p>Returns: - <code>matplotlib.figure.Figure</code>: Plot figure </p>"},{"location":"reference/config/","title":"Configuration Reference","text":"<p>This reference documents the configuration system and available configuration options in Tabular SSL.</p>"},{"location":"reference/config/#configuration-system","title":"Configuration System","text":"<p>Tabular SSL uses Hydra for configuration management, with Pydantic for validation.</p>"},{"location":"reference/config/#main-configuration-file","title":"Main Configuration File","text":"<p>The main configuration file (<code>configs/config.yaml</code>) is the entry point for configuration:</p> <pre><code># @package _global_\n\n# Default configurations that will be merged\ndefaults:\n  - _self_\n  - paths: default.yaml\n  - hydra: default.yaml\n  - model: default.yaml\n  - data: default.yaml\n  - trainer: default.yaml\n  - callbacks: default.yaml\n  - logger: default.yaml\n  - experiment: null  # No default experiment\n  - debug: null  # No debug mode by default\n\n# Project information\nproject_name: \"tabular-ssl\"\nproject_version: \"0.1.0\"\n\n# Training parameters\ntask_name: \"ssl\"\ntags: [\"tabular\", \"ssl\"]\nseed: 42\ndebug: false\n\n# Experiment tracking\nlog_dir: ${paths.log_dir}\ncheckpoint_dir: ${paths.checkpoint_dir}\n</code></pre>"},{"location":"reference/config/#component-configurations","title":"Component Configurations","text":""},{"location":"reference/config/#model-configuration","title":"Model Configuration","text":"<p>The model configuration (<code>configs/model/default.yaml</code>) specifies the model architecture:</p> <pre><code># configs/model/default.yaml\ndefaults:\n  - _self_\n  - event_encoder: mlp.yaml\n  - sequence_encoder: transformer.yaml\n  - embedding: categorical.yaml\n  - projection_head: mlp.yaml\n  - prediction_head: classification.yaml\n\n_target_: tabular_ssl.models.base.BaseModel\n\nmodel:\n  name: tabular_ssl_model\n  type: base\n  event_encoder: ${event_encoder}\n  sequence_encoder: ${sequence_encoder}\n  embedding: ${embedding}\n  projection_head: ${projection_head}\n  prediction_head: ${prediction_head}\n\n  # Optimizer settings\n  optimizer:\n    _target_: torch.optim.Adam\n    lr: 1.0e-3\n    weight_decay: 0.0\n\n  # Learning rate scheduler\n  lr_scheduler:\n    _target_: torch.optim.lr_scheduler.ReduceLROnPlateau\n    mode: min\n    factor: 0.5\n    patience: 5\n</code></pre>"},{"location":"reference/config/#event-encoder-configurations","title":"Event Encoder Configurations","text":""},{"location":"reference/config/#mlp-event-encoder","title":"MLP Event Encoder","text":"<pre><code># configs/model/event_encoder/mlp.yaml\nname: mlp_encoder\ntype: mlp_event_encoder\ninput_dim: 64\nhidden_dims: [128, 256]\noutput_dim: 512\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"reference/config/#autoencoder-event-encoder","title":"Autoencoder Event Encoder","text":"<pre><code># configs/model/event_encoder/autoencoder.yaml\nname: autoencoder_encoder\ntype: autoencoder\ninput_dim: 64\nhidden_dims: [128, 64]\noutput_dim: 32\ndropout: 0.1\nuse_batch_norm: true\nuse_reconstruction_loss: true\n</code></pre>"},{"location":"reference/config/#contrastive-event-encoder","title":"Contrastive Event Encoder","text":"<pre><code># configs/model/event_encoder/contrastive.yaml\nname: contrastive_encoder\ntype: contrastive\ninput_dim: 64\nhidden_dims: [128, 64]\noutput_dim: 32\ndropout: 0.1\nuse_batch_norm: true\ntemperature: 0.07\n</code></pre>"},{"location":"reference/config/#sequence-encoder-configurations","title":"Sequence Encoder Configurations","text":""},{"location":"reference/config/#transformer-encoder","title":"Transformer Encoder","text":"<pre><code># configs/model/sequence_encoder/transformer.yaml\nname: transformer_encoder\ntype: transformer\ninput_dim: 512\nhidden_dim: 512\nnum_layers: 4\nnum_heads: 8\ndim_feedforward: 2048\ndropout: 0.1\nbidirectional: true\n</code></pre>"},{"location":"reference/config/#lstm-encoder","title":"LSTM Encoder","text":"<pre><code># configs/model/sequence_encoder/lstm.yaml\nname: lstm_encoder\ntype: lstm\ninput_dim: 512\nhidden_dim: 512\nnum_layers: 2\ndropout: 0.1\nbidirectional: true\n</code></pre>"},{"location":"reference/config/#s4-encoder","title":"S4 Encoder","text":"<pre><code># configs/model/sequence_encoder/s4.yaml\nname: s4_encoder\ntype: s4\nd_model: 512\nd_state: 64\ndropout: 0.1\nbidirectional: true\nmax_sequence_length: 2048\nuse_checkpoint: false\n</code></pre>"},{"location":"reference/config/#embedding-configurations","title":"Embedding Configurations","text":"<pre><code># configs/model/embedding/categorical.yaml\nname: categorical_embedding\ntype: categorical_embedding\nembedding_dims:\n  - [5, 8]  # 5 categories, 8-dimensional embedding\n  - [3, 4]  # 3 categories, 4-dimensional embedding\ndropout: 0.1\n</code></pre>"},{"location":"reference/config/#projection-head-configurations","title":"Projection Head Configurations","text":"<pre><code># configs/model/projection_head/mlp.yaml\nname: mlp_projection\ntype: mlp_projection\ninput_dim: 512\nhidden_dims: [256]\noutput_dim: 128\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"reference/config/#prediction-head-configurations","title":"Prediction Head Configurations","text":"<pre><code># configs/model/prediction_head/classification.yaml\nname: classification_head\ntype: classification\ninput_dim: 128\nnum_classes: 2\nhidden_dims: [64]\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"reference/config/#data-configurations","title":"Data Configurations","text":"<pre><code># configs/data/default.yaml\n_target_: tabular_ssl.data.TabularDataModule\n\ndata:\n  name: default_dataset\n  path: ${paths.data_dir}/dataset.csv\n  train_ratio: 0.8\n  val_ratio: 0.1\n  test_ratio: 0.1\n  batch_size: 32\n  num_workers: 4\n  shuffle: true\n  drop_last: false\n  normalize: true\n  categorical_columns: []\n  numerical_columns: []\n  target_column: null  # For supervised learning\n</code></pre>"},{"location":"reference/config/#trainer-configurations","title":"Trainer Configurations","text":"<pre><code># configs/trainer/default.yaml\n_target_: pytorch_lightning.Trainer\n\ntrainer:\n  accelerator: auto\n  strategy: auto\n  devices: auto\n  num_nodes: 1\n  precision: 32\n  max_epochs: 100\n  min_epochs: 1\n  max_steps: -1\n  min_steps: null\n  limit_train_batches: 1.0\n  limit_val_batches: 1.0\n  limit_test_batches: 1.0\n  limit_predict_batches: 1.0\n  fast_dev_run: false\n  overfit_batches: 0.0\n  val_check_interval: 1.0\n  check_val_every_n_epoch: 1\n  num_sanity_val_steps: 2\n  log_every_n_steps: 50\n  enable_checkpointing: true\n  enable_progress_bar: true\n  enable_model_summary: true\n  accumulate_grad_batches: 1\n  gradient_clip_val: null\n  gradient_clip_algorithm: norm\n  deterministic: false\n  benchmark: false\n  inference_mode: true\n  use_distributed_sampler: true\n  detect_anomaly: false\n  barebones: false\n  plugins: null\n  sync_batchnorm: false\n  reload_dataloaders_every_n_epochs: 0\n</code></pre>"},{"location":"reference/config/#callbacks-configurations","title":"Callbacks Configurations","text":"<pre><code># configs/callbacks/default.yaml\ndefaults:\n  - _self_\n\ncallbacks:\n  model_checkpoint:\n    _target_: pytorch_lightning.callbacks.ModelCheckpoint\n    dirpath: ${checkpoint_dir}\n    filename: \"epoch_{epoch:03d}-val_loss_{val/loss:.4f}\"\n    monitor: \"val/loss\"\n    mode: \"min\"\n    save_last: true\n    save_top_k: 3\n    auto_insert_metric_name: false\n\n  early_stopping:\n    _target_: pytorch_lightning.callbacks.EarlyStopping\n    monitor: \"val/loss\"\n    patience: 10\n    mode: \"min\"\n    min_delta: 0.0001\n\n  lr_monitor:\n    _target_: pytorch_lightning.callbacks.LearningRateMonitor\n    logging_interval: \"epoch\"\n</code></pre>"},{"location":"reference/config/#logger-configurations","title":"Logger Configurations","text":"<pre><code># configs/logger/default.yaml\ndefaults:\n  - _self_\n\nlogger:\n  tensorboard:\n    _target_: pytorch_lightning.loggers.TensorBoardLogger\n    save_dir: ${log_dir}\n    name: null\n    version: null\n    log_graph: false\n    default_hp_metric: true\n    prefix: \"\"\n</code></pre>"},{"location":"reference/config/#experiment-configurations","title":"Experiment Configurations","text":"<p>Experiment configurations are stored in <code>configs/experiment/</code> and can override any of the above configurations.</p> <pre><code># configs/experiment/transformer_ssl.yaml\n# @package _global_\n\ndefaults:\n  - override /model/event_encoder: mlp.yaml\n  - override /model/sequence_encoder: transformer.yaml\n  - override /trainer: default.yaml\n  - override /model: default.yaml\n  - override /callbacks: default.yaml\n  - _self_\n\ntags: [\"transformer\", \"ssl\"]\n\nseed: 12345\n\ntrainer:\n  max_epochs: 100\n  gradient_clip_val: 0.5\n\nmodel:\n  optimizer:\n    lr: 1.0e-4\n    weight_decay: 0.01\n</code></pre>"},{"location":"reference/config/#debug-configurations","title":"Debug Configurations","text":"<p>Debug configurations provide settings for development and debugging:</p> <pre><code># configs/debug/default.yaml\n# @package _global_\n\n# Enable debug mode\ndebug: true\n\n# Reduce dataset size for faster iterations\ndata:\n  train_ratio: 0.05\n  val_ratio: 0.05\n  test_ratio: 0.05\n  batch_size: 8\n  num_workers: 0\n\n# Reduce training time\ntrainer:\n  max_epochs: 5\n  limit_train_batches: 10\n  limit_val_batches: 10\n  limit_test_batches: 10\n  log_every_n_steps: 1\n  num_sanity_val_steps: 0\n\n# Disable checkpointing\ncallbacks:\n  model_checkpoint:\n    save_top_k: 1\n    every_n_epochs: 1\n</code></pre>"},{"location":"reference/config/#environment-variables","title":"Environment Variables","text":"<p>The configuration system supports environment variables using the <code>${oc.env:VAR_NAME,default_value}</code> syntax.</p> <p>For example:</p> <pre><code>paths:\n  data_dir: ${oc.env:DATA_DIR,${project_path}/data}\n</code></pre>"},{"location":"reference/config/#command-line-overrides","title":"Command-line Overrides","text":"<p>Any configuration parameter can be overridden from the command line:</p> <pre><code>python src/train.py model.optimizer.lr=0.001 trainer.max_epochs=50\n</code></pre>"},{"location":"reference/config/#multi-run-parameter-sweeps","title":"Multi-run (Parameter Sweeps)","text":"<p>Multiple runs with different parameters can be executed using the <code>-m</code> flag:</p> <pre><code>python src/train.py -m model.optimizer.lr=1e-3,1e-4,1e-5\n</code></pre>"},{"location":"reference/config/#see-also","title":"See Also","text":"<ul> <li>Configuring Experiments: Guide for creating and running experiments</li> <li>Hydra Documentation: Official Hydra documentation </li> </ul>"},{"location":"reference/data/","title":"Data Utilities Reference","text":"<p>This section provides detailed documentation of the data loading and preprocessing utilities in Tabular SSL.</p>"},{"location":"reference/data/#dataloader","title":"DataLoader","text":"<p>The main class for loading and preprocessing tabular data.</p> <pre><code>from tabular_ssl.data import DataLoader\n</code></pre>"},{"location":"reference/data/#methods","title":"Methods","text":""},{"location":"reference/data/#load_datafile_path-target_colnone","title":"<code>load_data(file_path, target_col=None)</code>","text":"<p>Load data from a file.</p> <p>Parameters: - <code>file_path</code> (str): Path to the data file - <code>target_col</code> (str, optional): Name of the target column</p> <p>Returns: - <code>pd.DataFrame</code>: Loaded data</p>"},{"location":"reference/data/#preprocessdata-categorical_colsnone-scale_numericaltrue-handle_missingtrue","title":"<code>preprocess(data, categorical_cols=None, scale_numerical=True, handle_missing=True)</code>","text":"<p>Preprocess the data.</p> <p>Parameters: - <code>data</code> (pd.DataFrame): Input data - <code>categorical_cols</code> (list, optional): List of categorical column names - <code>scale_numerical</code> (bool, optional): Whether to scale numerical features - <code>handle_missing</code> (bool, optional): Whether to handle missing values</p> <p>Returns: - <code>pd.DataFrame</code>: Preprocessed data</p>"},{"location":"reference/data/#data-transformers","title":"Data Transformers","text":""},{"location":"reference/data/#categoricaltransformer","title":"CategoricalTransformer","text":"<pre><code>from tabular_ssl.data import CategoricalTransformer\n\ntransformer = CategoricalTransformer(\n    columns=['category1', 'category2'],\n    encoding='onehot'\n)\n</code></pre>"},{"location":"reference/data/#numericaltransformer","title":"NumericalTransformer","text":"<pre><code>from tabular_ssl.data import NumericalTransformer\n\ntransformer = NumericalTransformer(\n    columns=['numeric1', 'numeric2'],\n    scaling='standard'\n)\n</code></pre>"},{"location":"reference/data/#data-validation","title":"Data Validation","text":""},{"location":"reference/data/#datavalidator","title":"DataValidator","text":"<pre><code>from tabular_ssl.data import DataValidator\n\nvalidator = DataValidator(\n    required_columns=['col1', 'col2'],\n    data_types={\n        'col1': 'numeric',\n        'col2': 'categorical'\n    }\n)\n</code></pre>"},{"location":"reference/data/#data-splitting","title":"Data Splitting","text":""},{"location":"reference/data/#datasplitter","title":"DataSplitter","text":"<pre><code>from tabular_ssl.data import DataSplitter\n\nsplitter = DataSplitter(\n    test_size=0.2,\n    val_size=0.1,\n    random_state=42\n)\n</code></pre>"},{"location":"reference/data/#feature-engineering","title":"Feature Engineering","text":""},{"location":"reference/data/#featureengineer","title":"FeatureEngineer","text":"<pre><code>from tabular_ssl.data import FeatureEngineer\n\nengineer = FeatureEngineer(\n    interactions=True,\n    polynomials=True,\n    degree=2\n)\n</code></pre>"},{"location":"reference/data/#data-augmentation","title":"Data Augmentation","text":""},{"location":"reference/data/#dataaugmenter","title":"DataAugmenter","text":"<pre><code>from tabular_ssl.data import DataAugmenter\n\naugmenter = DataAugmenter(\n    noise_level=0.1,\n    mask_ratio=0.15\n)\n</code></pre>"},{"location":"reference/data/#common-operations","title":"Common Operations","text":""},{"location":"reference/data/#loading-data","title":"Loading Data","text":"<pre><code># Load from CSV\ndata = DataLoader().load_data('data.csv')\n\n# Load from DataFrame\ndata = DataLoader().load_data(df)\n</code></pre>"},{"location":"reference/data/#preprocessing","title":"Preprocessing","text":"<pre><code># Basic preprocessing\nprocessed_data = DataLoader().preprocess(\n    data,\n    categorical_cols=['category1', 'category2']\n)\n\n# Advanced preprocessing\nprocessed_data = DataLoader().preprocess(\n    data,\n    categorical_cols=['category1', 'category2'],\n    scale_numerical=True,\n    handle_missing=True,\n    missing_strategy='mean'\n)\n</code></pre>"},{"location":"reference/data/#data-splitting_1","title":"Data Splitting","text":"<pre><code># Split data\ntrain_data, val_data, test_data = DataSplitter().split(data)\n</code></pre>"},{"location":"reference/data/#feature-engineering_1","title":"Feature Engineering","text":"<pre><code># Create new features\nengineered_data = FeatureEngineer().transform(data)\n</code></pre>"},{"location":"reference/data/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate data before processing</li> <li>Handle missing values appropriately</li> <li>Scale numerical features</li> <li>Encode categorical variables</li> <li>Split data before preprocessing</li> <li>Document preprocessing steps</li> <li>Save preprocessed data</li> <li>Use appropriate data types</li> </ol>"},{"location":"reference/data/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>How-to Guides - Data preparation guides</li> <li>Tutorials - Getting started guides </li> </ul>"},{"location":"reference/models/","title":"Models Reference","text":"<p>This section provides detailed documentation of the model components and configurations available in Tabular SSL.</p>"},{"location":"reference/models/#component-registry","title":"Component Registry","text":"<p>The <code>ComponentRegistry</code> is a central registry that manages all model components.</p> <pre><code>from tabular_ssl.models.base import ComponentRegistry\n</code></pre>"},{"location":"reference/models/#registry-methods","title":"Registry Methods","text":""},{"location":"reference/models/#registername-str","title":"<code>register(name: str)</code>","text":"<p>Register a component class with the registry.</p> <pre><code>@ComponentRegistry.register(\"custom_component\")\nclass CustomComponent(BaseComponent):\n    def __init__(self, config: ComponentConfig):\n        super().__init__(config)\n        # Implementation...\n</code></pre>"},{"location":"reference/models/#getname-str-typebasecomponent","title":"<code>get(name: str) -&gt; Type[BaseComponent]</code>","text":"<p>Get a component class by name.</p> <pre><code>component_cls = ComponentRegistry.get(\"transformer\")\n</code></pre>"},{"location":"reference/models/#list_components-dictstr-typebasecomponent","title":"<code>list_components() -&gt; Dict[str, Type[BaseComponent]]</code>","text":"<p>Get a dictionary of all registered components.</p> <pre><code>available_components = ComponentRegistry.list_components()\n</code></pre>"},{"location":"reference/models/#base-components","title":"Base Components","text":""},{"location":"reference/models/#basecomponent","title":"<code>BaseComponent</code>","text":"<p>The abstract base class for all model components.</p> <pre><code>from tabular_ssl.models.base import BaseComponent\n</code></pre>"},{"location":"reference/models/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, config: ComponentConfig):\n    super().__init__()\n    self.config = config\n    self._validate_config()\n</code></pre>"},{"location":"reference/models/#methods","title":"Methods","text":""},{"location":"reference/models/#_validate_config-none","title":"<code>_validate_config() -&gt; None</code>","text":"<p>Validate the component configuration.</p>"},{"location":"reference/models/#forwardx-torchtensor-torchtensor","title":"<code>forward(x: torch.Tensor) -&gt; torch.Tensor</code>","text":"<p>Abstract method for the forward pass.</p>"},{"location":"reference/models/#eventencoder","title":"<code>EventEncoder</code>","text":"<p>Base class for event encoders.</p> <pre><code>from tabular_ssl.models.base import EventEncoder\n</code></pre>"},{"location":"reference/models/#sequenceencoder","title":"<code>SequenceEncoder</code>","text":"<p>Base class for sequence encoders.</p> <pre><code>from tabular_ssl.models.base import SequenceEncoder\n</code></pre>"},{"location":"reference/models/#embeddinglayer","title":"<code>EmbeddingLayer</code>","text":"<p>Base class for embedding layers.</p> <pre><code>from tabular_ssl.models.base import EmbeddingLayer\n</code></pre>"},{"location":"reference/models/#projectionhead","title":"<code>ProjectionHead</code>","text":"<p>Base class for projection heads.</p> <pre><code>from tabular_ssl.models.base import ProjectionHead\n</code></pre>"},{"location":"reference/models/#predictionhead","title":"<code>PredictionHead</code>","text":"<p>Base class for prediction heads.</p> <pre><code>from tabular_ssl.models.base import PredictionHead\n</code></pre>"},{"location":"reference/models/#component-configurations","title":"Component Configurations","text":""},{"location":"reference/models/#componentconfig","title":"<code>ComponentConfig</code>","text":"<p>Base configuration for components.</p> <pre><code>from tabular_ssl.models.base import ComponentConfig\n</code></pre>"},{"location":"reference/models/#fields","title":"Fields","text":"<ul> <li><code>name</code> (str): Name of the component</li> <li><code>type</code> (str): Type of the component</li> </ul>"},{"location":"reference/models/#mlpconfig","title":"<code>MLPConfig</code>","text":"<p>Configuration for MLP-based components.</p> <pre><code>from tabular_ssl.models.components import MLPConfig\n</code></pre>"},{"location":"reference/models/#fields_1","title":"Fields","text":"<ul> <li><code>input_dim</code> (int): Input dimension</li> <li><code>hidden_dims</code> (List[int]): List of hidden dimensions</li> <li><code>output_dim</code> (int): Output dimension</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> <li><code>use_batch_norm</code> (bool, default=True): Whether to use batch normalization</li> </ul>"},{"location":"reference/models/#sequencemodelconfig","title":"<code>SequenceModelConfig</code>","text":"<p>Base configuration for sequence models.</p> <pre><code>from tabular_ssl.models.components import SequenceModelConfig\n</code></pre>"},{"location":"reference/models/#fields_2","title":"Fields","text":"<ul> <li><code>input_dim</code> (int): Input dimension</li> <li><code>hidden_dim</code> (int): Hidden dimension</li> <li><code>num_layers</code> (int, default=1): Number of layers</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> <li><code>bidirectional</code> (bool, default=False): Whether to use bidirectional processing</li> </ul>"},{"location":"reference/models/#transformerconfig","title":"<code>TransformerConfig</code>","text":"<p>Configuration for Transformer models.</p> <pre><code>from tabular_ssl.models.components import TransformerConfig\n</code></pre>"},{"location":"reference/models/#fields_3","title":"Fields","text":"<ul> <li>All fields from <code>SequenceModelConfig</code></li> <li><code>num_heads</code> (int, default=4): Number of attention heads</li> <li><code>dim_feedforward</code> (int): Dimension of feedforward network</li> </ul>"},{"location":"reference/models/#s4config","title":"<code>S4Config</code>","text":"<p>Configuration for S4 models.</p> <pre><code>from tabular_ssl.models.s4 import S4Config\n</code></pre>"},{"location":"reference/models/#fields_4","title":"Fields","text":"<ul> <li><code>d_model</code> (int): Model dimension</li> <li><code>d_state</code> (int): State dimension</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> <li><code>bidirectional</code> (bool, default=False): Whether to use bidirectional processing</li> <li><code>max_sequence_length</code> (int, default=2048): Maximum sequence length</li> </ul>"},{"location":"reference/models/#embeddingconfig","title":"<code>EmbeddingConfig</code>","text":"<p>Configuration for embedding layers.</p> <pre><code>from tabular_ssl.models.components import EmbeddingConfig\n</code></pre>"},{"location":"reference/models/#fields_5","title":"Fields","text":"<ul> <li><code>embedding_dims</code> (List[tuple[int, int]]): List of (num_categories, embedding_dim) tuples</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> </ul>"},{"location":"reference/models/#projectionheadconfig","title":"<code>ProjectionHeadConfig</code>","text":"<p>Configuration for projection heads.</p> <pre><code>from tabular_ssl.models.components import ProjectionHeadConfig\n</code></pre>"},{"location":"reference/models/#fields_6","title":"Fields","text":"<ul> <li><code>input_dim</code> (int): Input dimension</li> <li><code>hidden_dims</code> (List[int]): List of hidden dimensions</li> <li><code>output_dim</code> (int): Output dimension</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> <li><code>use_batch_norm</code> (bool, default=True): Whether to use batch normalization</li> </ul>"},{"location":"reference/models/#predictionheadconfig","title":"<code>PredictionHeadConfig</code>","text":"<p>Configuration for prediction heads.</p> <pre><code>from tabular_ssl.models.components import PredictionHeadConfig\n</code></pre>"},{"location":"reference/models/#fields_7","title":"Fields","text":"<ul> <li><code>input_dim</code> (int): Input dimension</li> <li><code>num_classes</code> (int): Number of output classes</li> <li><code>hidden_dims</code> (Optional[List[int]], default=None): Optional list of hidden dimensions</li> <li><code>dropout</code> (float, default=0.1): Dropout rate</li> <li><code>use_batch_norm</code> (bool, default=True): Whether to use batch normalization</li> </ul>"},{"location":"reference/models/#component-implementations","title":"Component Implementations","text":""},{"location":"reference/models/#event-encoders","title":"Event Encoders","text":""},{"location":"reference/models/#mlpeventencoder","title":"<code>MLPEventEncoder</code>","text":"<p>A simple MLP-based event encoder.</p> <pre><code>from tabular_ssl.models.components import MLPEventEncoder\n</code></pre>"},{"location":"reference/models/#autoencodereventencoder","title":"<code>AutoEncoderEventEncoder</code>","text":"<p>Autoencoder-based event encoder.</p> <pre><code>from tabular_ssl.models.components import AutoEncoderEventEncoder\n</code></pre>"},{"location":"reference/models/#methods_1","title":"Methods","text":""},{"location":"reference/models/#decodez-torchtensor-torchtensor","title":"<code>decode(z: torch.Tensor) -&gt; torch.Tensor</code>","text":"<p>Decode the latent representation.</p>"},{"location":"reference/models/#reconstruction_lossx-torchtensor-torchtensor","title":"<code>reconstruction_loss(x: torch.Tensor) -&gt; torch.Tensor</code>","text":"<p>Compute reconstruction loss.</p>"},{"location":"reference/models/#contrastiveeventencoder","title":"<code>ContrastiveEventEncoder</code>","text":"<p>Contrastive learning-based event encoder.</p> <pre><code>from tabular_ssl.models.components import ContrastiveEventEncoder\n</code></pre>"},{"location":"reference/models/#methods_2","title":"Methods","text":""},{"location":"reference/models/#contrastive_lossz1-torchtensor-z2-torchtensor-torchtensor","title":"<code>contrastive_loss(z1: torch.Tensor, z2: torch.Tensor) -&gt; torch.Tensor</code>","text":"<p>Compute contrastive loss between two views.</p>"},{"location":"reference/models/#sequence-encoders","title":"Sequence Encoders","text":""},{"location":"reference/models/#rnnsequencemodel","title":"<code>RNNSequenceModel</code>","text":"<p>Basic RNN sequence model.</p> <pre><code>from tabular_ssl.models.components import RNNSequenceModel\n</code></pre>"},{"location":"reference/models/#lstmsequencemodel","title":"<code>LSTMSequenceModel</code>","text":"<p>LSTM sequence model.</p> <pre><code>from tabular_ssl.models.components import LSTMSequenceModel\n</code></pre>"},{"location":"reference/models/#grusequencemodel","title":"<code>GRUSequenceModel</code>","text":"<p>GRU sequence model.</p> <pre><code>from tabular_ssl.models.components import GRUSequenceModel\n</code></pre>"},{"location":"reference/models/#transformersequencemodel","title":"<code>TransformerSequenceModel</code>","text":"<p>Transformer sequence model.</p> <pre><code>from tabular_ssl.models.components import TransformerSequenceModel\n</code></pre>"},{"location":"reference/models/#s4model","title":"<code>S4Model</code>","text":"<p>S4 sequence model with multiple S4 blocks.</p> <pre><code>from tabular_ssl.models.s4 import S4Model\n</code></pre>"},{"location":"reference/models/#embedding-layers","title":"Embedding Layers","text":""},{"location":"reference/models/#categoricalembedding","title":"<code>CategoricalEmbedding</code>","text":"<p>Embedding layer for categorical variables.</p> <pre><code>from tabular_ssl.models.components import CategoricalEmbedding\n</code></pre>"},{"location":"reference/models/#projection-heads","title":"Projection Heads","text":""},{"location":"reference/models/#mlpprojectionhead","title":"<code>MLPProjectionHead</code>","text":"<p>MLP-based projection head.</p> <pre><code>from tabular_ssl.models.components import MLPProjectionHead\n</code></pre>"},{"location":"reference/models/#prediction-heads","title":"Prediction Heads","text":""},{"location":"reference/models/#classificationhead","title":"<code>ClassificationHead</code>","text":"<p>Classification head.</p> <pre><code>from tabular_ssl.models.components import ClassificationHead\n</code></pre>"},{"location":"reference/models/#corruption-strategies","title":"Corruption Strategies","text":""},{"location":"reference/models/#randommasking","title":"<code>RandomMasking</code>","text":"<p>Random masking corruption strategy.</p> <pre><code>from tabular_ssl.models.components import RandomMasking\n</code></pre>"},{"location":"reference/models/#gaussiannoise","title":"<code>GaussianNoise</code>","text":"<p>Gaussian noise corruption strategy.</p> <pre><code>from tabular_ssl.models.components import GaussianNoise\n</code></pre>"},{"location":"reference/models/#swappingcorruption","title":"<code>SwappingCorruption</code>","text":"<p>Feature swapping corruption strategy.</p> <pre><code>from tabular_ssl.models.components import SwappingCorruption\n</code></pre>"},{"location":"reference/models/#vimecorruption","title":"<code>VIMECorruption</code>","text":"<p>VIME-style corruption strategy.</p> <pre><code>from tabular_ssl.models.components import VIMECorruption\n</code></pre>"},{"location":"reference/models/#corruptionpipeline","title":"<code>CorruptionPipeline</code>","text":"<p>Pipeline of corruption strategies.</p> <pre><code>from tabular_ssl.models.components import CorruptionPipeline\n</code></pre>"},{"location":"reference/models/#base-model","title":"Base Model","text":""},{"location":"reference/models/#basemodel","title":"<code>BaseModel</code>","text":"<p>Base model class for self-supervised sequence modeling.</p> <pre><code>from tabular_ssl.models.base import BaseModel\n</code></pre>"},{"location":"reference/models/#constructor_1","title":"Constructor","text":"<pre><code>def __init__(self, config: DictConfig):\n    super().__init__()\n    self.config = config\n\n    # Convert Hydra configs to ComponentConfigs\n    self.component_configs = {\n        name: ComponentConfig.from_hydra(cfg)\n        for name, cfg in config.model.items() if cfg is not None\n    }\n\n    # Initialize components\n    self.components = {\n        name: self._init_component(cfg)\n        for name, cfg in self.component_configs.items()\n    }\n\n    self.save_hyperparameters(OmegaConf.to_container(config, resolve=True))\n</code></pre>"},{"location":"reference/models/#methods_3","title":"Methods","text":""},{"location":"reference/models/#_init_componentconfig-componentconfig-basecomponent","title":"<code>_init_component(config: ComponentConfig) -&gt; BaseComponent</code>","text":"<p>Initialize a component from its configuration.</p>"},{"location":"reference/models/#forwardx-torchtensor-torchtensor_1","title":"<code>forward(x: torch.Tensor) -&gt; torch.Tensor</code>","text":"<p>Forward pass through the model.</p>"},{"location":"reference/models/#training_stepbatch-batch_idx","title":"<code>training_step(batch, batch_idx)</code>","text":"<p>Training step (to be implemented by subclasses).</p>"},{"location":"reference/models/#validation_stepbatch-batch_idx","title":"<code>validation_step(batch, batch_idx)</code>","text":"<p>Validation step (to be implemented by subclasses).</p>"},{"location":"reference/models/#configure_optimizers","title":"<code>configure_optimizers()</code>","text":"<p>Configure optimizers.</p>"},{"location":"reference/models/#configuration-examples","title":"Configuration Examples","text":""},{"location":"reference/models/#event-encoder-configuration","title":"Event Encoder Configuration","text":"<pre><code># Example configuration for an MLP event encoder\nname: mlp_encoder\ntype: mlp_event_encoder\ninput_dim: 64\nhidden_dims: [128, 256]\noutput_dim: 512\ndropout: 0.1\nuse_batch_norm: true\n</code></pre>"},{"location":"reference/models/#sequence-encoder-configuration","title":"Sequence Encoder Configuration","text":"<pre><code># Example configuration for a Transformer sequence encoder\nname: transformer_encoder\ntype: transformer\ninput_dim: 512\nhidden_dim: 512\nnum_layers: 4\nnum_heads: 8\ndim_feedforward: 2048\ndropout: 0.1\nbidirectional: true\n</code></pre>"},{"location":"reference/models/#model-configuration","title":"Model Configuration","text":"<pre><code># Example model configuration\nmodel:\n  event_encoder:\n    name: mlp_event_encoder\n    type: mlp_event_encoder\n    input_dim: 64\n    hidden_dims: [128, 256]\n    output_dim: 512\n    dropout: 0.1\n    use_batch_norm: true\n  sequence_encoder:\n    name: s4\n    type: s4\n    input_dim: 512\n    hidden_dim: 64\n    num_layers: 2\n    dropout: 0.1\n    bidirectional: true\n    max_sequence_length: 2048\n  projection_head:\n    name: mlp_projection\n    type: mlp_projection\n    input_dim: 512\n    hidden_dims: [256]\n    output_dim: 128\n    dropout: 0.1\n    use_batch_norm: true\noptimizer:\n  _target_: torch.optim.Adam\n  lr: 0.001\n</code></pre>"},{"location":"reference/utils/","title":"Utility Functions Reference","text":"<p>This section provides detailed documentation of the utility functions and tools in Tabular SSL.</p>"},{"location":"reference/utils/#evaluation-utilities","title":"Evaluation Utilities","text":""},{"location":"reference/utils/#model-evaluation","title":"Model Evaluation","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\n</code></pre>"},{"location":"reference/utils/#cross-validation","title":"Cross-Validation","text":"<pre><code>from tabular_ssl.utils import cross_validate\n\ncv_results = cross_validate(\n    model,\n    data,\n    n_splits=5,\n    metrics=['accuracy', 'f1']\n)\n</code></pre>"},{"location":"reference/utils/#visualization-utilities","title":"Visualization Utilities","text":""},{"location":"reference/utils/#training-history","title":"Training History","text":"<pre><code>from tabular_ssl.utils import plot_training_history\n\nfig = plot_training_history(history)\nfig.show()\n</code></pre>"},{"location":"reference/utils/#performance-plots","title":"Performance Plots","text":"<pre><code>from tabular_ssl.utils import plot_performance\n\nfig = plot_performance(\n    model,\n    test_data,\n    plot_types=['confusion_matrix', 'roc_curve']\n)\nfig.show()\n</code></pre>"},{"location":"reference/utils/#model-interpretation","title":"Model Interpretation","text":""},{"location":"reference/utils/#feature-importance","title":"Feature Importance","text":"<pre><code>from tabular_ssl.utils import get_feature_importance\n\nimportance = get_feature_importance(model, test_data)\n</code></pre>"},{"location":"reference/utils/#shap-values","title":"SHAP Values","text":"<pre><code>from tabular_ssl.utils import get_shap_values\n\nshap_values = get_shap_values(model, test_data)\n</code></pre>"},{"location":"reference/utils/#hyperparameter-tuning","title":"Hyperparameter Tuning","text":""},{"location":"reference/utils/#grid-search","title":"Grid Search","text":"<pre><code>from tabular_ssl.utils import grid_search\n\nbest_params = grid_search(\n    model_class=TabularSSL,\n    param_grid={\n        'hidden_dim': [128, 256, 512],\n        'num_layers': [2, 4, 6]\n    },\n    train_data=train_data,\n    val_data=val_data\n)\n</code></pre>"},{"location":"reference/utils/#random-search","title":"Random Search","text":"<pre><code>from tabular_ssl.utils import random_search\n\nbest_params = random_search(\n    model_class=TabularSSL,\n    param_distributions={\n        'hidden_dim': [128, 256, 512],\n        'num_layers': [2, 4, 6]\n    },\n    train_data=train_data,\n    val_data=val_data,\n    n_iter=10\n)\n</code></pre>"},{"location":"reference/utils/#data-utilities","title":"Data Utilities","text":""},{"location":"reference/utils/#data-validation","title":"Data Validation","text":"<pre><code>from tabular_ssl.utils import validate_data\n\nvalidation_results = validate_data(data)\n</code></pre>"},{"location":"reference/utils/#feature-selection","title":"Feature Selection","text":"<pre><code>from tabular_ssl.utils import select_features\n\nselected_features = select_features(\n    data,\n    target_col='target',\n    method='importance',\n    threshold=0.01\n)\n</code></pre>"},{"location":"reference/utils/#model-utilities","title":"Model Utilities","text":""},{"location":"reference/utils/#model-saving","title":"Model Saving","text":"<pre><code>from tabular_ssl.utils import save_model\n\nsave_model(model, 'model.pt')\n</code></pre>"},{"location":"reference/utils/#model-loading","title":"Model Loading","text":"<pre><code>from tabular_ssl.utils import load_model\n\nmodel = load_model('model.pt')\n</code></pre>"},{"location":"reference/utils/#training-utilities","title":"Training Utilities","text":""},{"location":"reference/utils/#learning-rate-scheduling","title":"Learning Rate Scheduling","text":"<pre><code>from tabular_ssl.utils import get_lr_scheduler\n\nscheduler = get_lr_scheduler(\n    initial_lr=1e-3,\n    scheduler_type='cosine',\n    warmup_epochs=5\n)\n</code></pre>"},{"location":"reference/utils/#early-stopping","title":"Early Stopping","text":"<pre><code>from tabular_ssl.utils import EarlyStopping\n\nearly_stopping = EarlyStopping(\n    patience=10,\n    min_delta=0.001\n)\n</code></pre>"},{"location":"reference/utils/#common-functions","title":"Common Functions","text":""},{"location":"reference/utils/#metrics","title":"Metrics","text":"<pre><code>from tabular_ssl.utils import (\n    accuracy_score,\n    f1_score,\n    precision_score,\n    recall_score\n)\n\n# Compute metrics\nacc = accuracy_score(y_true, y_pred)\nf1 = f1_score(y_true, y_pred)\n</code></pre>"},{"location":"reference/utils/#data-processing","title":"Data Processing","text":"<pre><code>from tabular_ssl.utils import (\n    normalize_data,\n    encode_categorical,\n    handle_missing\n)\n\n# Process data\nnormalized_data = normalize_data(data)\nencoded_data = encode_categorical(data, categorical_cols)\ncleaned_data = handle_missing(data, strategy='mean')\n</code></pre>"},{"location":"reference/utils/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate evaluation metrics</li> <li>Implement proper cross-validation</li> <li>Visualize results for better understanding</li> <li>Document utility function usage</li> <li>Handle errors gracefully</li> <li>Use type hints for better code clarity</li> <li>Add proper docstrings</li> <li>Include examples in documentation</li> </ol>"},{"location":"reference/utils/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>How-to Guides - Evaluation guides</li> <li>Tutorials - Usage examples </li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Tabular SSL tutorials section. Here you'll find step-by-step guides to help you get started with the library.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"<ul> <li>Getting Started - Learn the basics of Tabular SSL</li> <li>Basic Usage - Explore common use cases and patterns</li> </ul>"},{"location":"tutorials/#whats-next","title":"What's Next?","text":"<p>After completing the tutorials, you might want to:</p> <ol> <li>Check out the How-to Guides for practical solutions</li> <li>Read the API Reference for detailed documentation</li> <li>Learn about the SSL Methods in depth </li> </ol>"},{"location":"tutorials/basic-usage/","title":"Basic Usage","text":"<p>This tutorial covers common use cases and patterns for working with Tabular SSL.</p>"},{"location":"tutorials/basic-usage/#working-with-different-data-types","title":"Working with Different Data Types","text":""},{"location":"tutorials/basic-usage/#numerical-data","title":"Numerical Data","text":"<pre><code>import pandas as pd\nfrom tabular_ssl import TabularSSL\nfrom hydra.utils import instantiate\nfrom omegaconf import OmegaConf\n\n# Create sample numerical data\ndata = pd.DataFrame({\n    'feature1': [1.0, 2.0, 3.0],\n    'feature2': [4.0, 5.0, 6.0]\n})\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 2\n})\n\n# Initialize and train model\nmodel = instantiate(config)\nmodel.train(data)\n</code></pre>"},{"location":"tutorials/basic-usage/#categorical-data","title":"Categorical Data","text":"<pre><code># Create sample categorical data\ndata = pd.DataFrame({\n    'category1': ['A', 'B', 'A'],\n    'category2': ['X', 'Y', 'Z']\n})\n\n# Preprocess categorical data\nfrom tabular_ssl.data import DataLoader\ndata_loader = DataLoader()\nprocessed_data = data_loader.preprocess(data, categorical_cols=['category1', 'category2'])\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': processed_data.shape[1]\n})\n\n# Train model\nmodel = instantiate(config)\nmodel.train(processed_data)\n</code></pre>"},{"location":"tutorials/basic-usage/#mixed-data-types","title":"Mixed Data Types","text":"<pre><code># Create sample mixed data\ndata = pd.DataFrame({\n    'numeric': [1.0, 2.0, 3.0],\n    'category': ['A', 'B', 'A']\n})\n\n# Preprocess data\nprocessed_data = data_loader.preprocess(\n    data,\n    categorical_cols=['category']\n)\n\n# Create configuration\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': processed_data.shape[1]\n})\n\n# Train model\nmodel = instantiate(config)\nmodel.train(processed_data)\n</code></pre>"},{"location":"tutorials/basic-usage/#model-configuration","title":"Model Configuration","text":""},{"location":"tutorials/basic-usage/#custom-architecture","title":"Custom Architecture","text":"<pre><code># Create configuration with custom architecture\nconfig = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.TransformerEncoder',\n        'input_dim': 10,\n        'hidden_dim': 512,    # Larger hidden dimension\n        'num_layers': 6,      # More transformer layers\n        'num_heads': 8,       # More attention heads\n        'dropout': 0.2        # Higher dropout\n    },\n    'mask_ratio': 0.2         # Higher masking ratio\n})\n\n# Initialize model\nmodel = instantiate(config)\n</code></pre>"},{"location":"tutorials/basic-usage/#training-configuration","title":"Training Configuration","text":"<pre><code># Create training configuration\ntrain_config = OmegaConf.create({\n    'batch_size': 64,         # Larger batch size\n    'epochs': 200,            # More epochs\n    'learning_rate': 5e-5,    # Lower learning rate\n    'weight_decay': 1e-4      # L2 regularization\n})\n\n# Train model\nhistory = model.train(\n    data=processed_data,\n    **train_config\n)\n</code></pre>"},{"location":"tutorials/basic-usage/#model-evaluation","title":"Model Evaluation","text":""},{"location":"tutorials/basic-usage/#computing-metrics","title":"Computing Metrics","text":"<pre><code>from tabular_ssl.utils import evaluate_model\n\nmetrics = evaluate_model(\n    model,\n    test_data,\n    metrics=['accuracy', 'f1', 'precision', 'recall']\n)\nprint(metrics)\n</code></pre>"},{"location":"tutorials/basic-usage/#visualization","title":"Visualization","text":"<pre><code>from tabular_ssl.utils import plot_training_history\nimport matplotlib.pyplot as plt\n\n# Plot training history\nfig = plot_training_history(history)\nplt.show()\n\n# Save the plot\nfig.savefig('training_history.png')\n</code></pre>"},{"location":"tutorials/basic-usage/#model-persistence","title":"Model Persistence","text":""},{"location":"tutorials/basic-usage/#saving-and-loading","title":"Saving and Loading","text":"<pre><code># Save model\nmodel.save('my_model.pt')\n\n# Load model\nloaded_model = TabularSSL.load('my_model.pt')\n</code></pre>"},{"location":"tutorials/basic-usage/#using-different-encoders","title":"Using Different Encoders","text":""},{"location":"tutorials/basic-usage/#transformer-encoder","title":"Transformer Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.TransformerEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 4,\n        'num_heads': 4\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#rnn-encoder","title":"RNN Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.RNNEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 2,\n        'bidirectional': true\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#lstm-encoder","title":"LSTM Encoder","text":"<pre><code>config = OmegaConf.create({\n    '_target_': 'tabular_ssl.models.TabularSSL',\n    'input_dim': 10,\n    'sequence_encoder': {\n        '_target_': 'tabular_ssl.models.encoders.LSTMEncoder',\n        'input_dim': 10,\n        'hidden_dim': 256,\n        'num_layers': 2,\n        'bidirectional': true\n    }\n})\n</code></pre>"},{"location":"tutorials/basic-usage/#understanding-hydra-configuration","title":"Understanding Hydra Configuration","text":""},{"location":"tutorials/basic-usage/#basic-concepts","title":"Basic Concepts","text":"<p>Hydra is a framework for elegantly configuring complex applications. Here are the key concepts:</p> <ol> <li> <p>Configuration Files <pre><code># configs/model/default.yaml\n_target_: tabular_ssl.models.TabularSSL\ninput_dim: 10\nsequence_encoder:\n  _target_: tabular_ssl.models.encoders.TransformerEncoder\n  input_dim: 10\n  hidden_dim: 256\n</code></pre></p> </li> <li> <p>Configuration Groups <pre><code># configs/model/transformer.yaml\n_target_: tabular_ssl.models.encoders.TransformerEncoder\ninput_dim: ${model.input_dim}\nhidden_dim: 256\nnum_heads: 4\n\n# configs/model/rnn.yaml\n_target_: tabular_ssl.models.encoders.RNNEncoder\ninput_dim: ${model.input_dim}\nhidden_dim: 256\nnum_layers: 2\n</code></pre></p> </li> <li> <p>Configuration Composition <pre><code># configs/experiment/transformer_experiment.yaml\ndefaults:\n  - model: transformer\n  - data: default\n  - trainer: default\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#using-hydra-in-code","title":"Using Hydra in Code","text":"<ol> <li> <p>Loading Configurations <pre><code>from hydra import compose, initialize\n\n# Initialize Hydra\nwith initialize(config_path=\"configs\"):\n    # Load default config\n    config = compose(config_name=\"config\")\n\n    # Load specific experiment\n    experiment_config = compose(config_name=\"experiment/transformer_experiment\")\n</code></pre></p> </li> <li> <p>Instantiating Objects <pre><code>from hydra.utils import instantiate\n\n# Create model from config\nmodel = instantiate(config.model)\n\n# Create optimizer\noptimizer = instantiate(config.optimizer, params=model.parameters())\n</code></pre></p> </li> <li> <p>Overriding Configuration <pre><code># Override specific values\nconfig = compose(\n    config_name=\"config\",\n    overrides=[\"model.sequence_encoder.hidden_dim=512\"]\n)\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#advanced-features","title":"Advanced Features","text":"<ol> <li> <p>Variable Interpolation <pre><code># configs/model/default.yaml\ninput_dim: 10\nsequence_encoder:\n  input_dim: ${model.input_dim}  # References parent config\n  hidden_dim: ${oc.env:HIDDEN_DIM,256}  # Uses environment variable with default\n</code></pre></p> </li> <li> <p>Configuration Inheritance <pre><code># configs/model/base.yaml\n_target_: tabular_ssl.models.TabularSSL\ninput_dim: 10\n\n# configs/model/large.yaml\ndefaults:\n  - base\nhidden_dim: 512\nnum_layers: 6\n</code></pre></p> </li> <li> <p>Structured Configs <pre><code>from dataclasses import dataclass\nfrom omegaconf import MISSING\n\n@dataclass\nclass ModelConfig:\n    _target_: str = MISSING\n    input_dim: int = MISSING\n    hidden_dim: int = 256\n\n@dataclass\nclass Config:\n    model: ModelConfig = MISSING\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#best-practices","title":"Best Practices","text":"<ol> <li>Configuration Organization</li> <li>Keep related configs together</li> <li>Use meaningful names</li> <li> <p>Document configuration options</p> </li> <li> <p>Default Values</p> </li> <li>Provide sensible defaults</li> <li>Use type hints</li> <li> <p>Document parameter ranges</p> </li> <li> <p>Error Handling <pre><code>from omegaconf import OmegaConf\n\n# Validate config\ntry:\n    OmegaConf.to_container(config, resolve=True)\nexcept Exception as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre></p> </li> <li> <p>Configuration Logging <pre><code># Log configuration\nprint(OmegaConf.to_yaml(config))\n\n# Save configuration\nOmegaConf.save(config, \"config.yaml\")\n</code></pre></p> </li> </ol>"},{"location":"tutorials/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Explore How-to Guides for more specific use cases</li> <li>Check the API Reference for detailed documentation</li> <li>Learn about SSL Methods in depth </li> </ul>"},{"location":"tutorials/custom-components/","title":"Creating Custom Components","text":"<p>This tutorial will guide you through creating custom components in Tabular SSL using the component registry.</p>"},{"location":"tutorials/custom-components/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of PyTorch</li> <li>Familiarity with the Tabular SSL architecture</li> <li>Python environment with Tabular SSL installed</li> </ul>"},{"location":"tutorials/custom-components/#introduction","title":"Introduction","text":"<p>Tabular SSL uses a component registry pattern that allows you to create and register custom components. This enables you to extend the library with your own custom event encoders, sequence encoders, or other components without modifying the core codebase.</p>"},{"location":"tutorials/custom-components/#step-1-create-a-configuration-class","title":"Step 1: Create a Configuration Class","text":"<p>First, define a configuration class for your component. This should inherit from the appropriate base configuration class.</p> <pre><code># src/tabular_ssl/models/custom_components.py\nfrom pydantic import Field\nfrom typing import List, Optional\n\nfrom tabular_ssl.models.base import ComponentConfig\n\nclass CustomEncoderConfig(ComponentConfig):\n    \"\"\"Configuration for custom encoder.\"\"\"\n\n    input_dim: int = Field(..., description=\"Input dimension\")\n    hidden_dims: List[int] = Field(..., description=\"Hidden dimensions\")\n    output_dim: int = Field(..., description=\"Output dimension\")\n    dropout: float = Field(0.1, description=\"Dropout rate\")\n    use_batch_norm: bool = Field(True, description=\"Whether to use batch normalization\")\n    activation: str = Field(\"relu\", description=\"Activation function\")\n</code></pre> <p>The configuration class uses Pydantic fields with validation and documentation. Required fields are marked with <code>...</code> as the default value, while optional fields have explicit defaults.</p>"},{"location":"tutorials/custom-components/#step-2-create-a-component-class","title":"Step 2: Create a Component Class","text":"<p>Next, create a component class that inherits from the appropriate base component class:</p> <pre><code># src/tabular_ssl/models/custom_components.py\nimport torch\nimport torch.nn as nn\n\nfrom tabular_ssl.models.base import EventEncoder, ComponentRegistry\n\n@ComponentRegistry.register(\"custom_encoder\")\nclass CustomEncoder(EventEncoder):\n    \"\"\"Custom event encoder implementation.\"\"\"\n\n    def __init__(self, config: CustomEncoderConfig):\n        super().__init__(config)\n        self.config = config\n\n        # Build the layers\n        self.layers = nn.ModuleList()\n        dims = [config.input_dim] + config.hidden_dims\n\n        for i in range(len(dims) - 1):\n            layer = []\n            layer.append(nn.Linear(dims[i], dims[i + 1]))\n\n            if config.use_batch_norm:\n                layer.append(nn.BatchNorm1d(dims[i + 1]))\n\n            if config.activation == \"relu\":\n                layer.append(nn.ReLU())\n            elif config.activation == \"leaky_relu\":\n                layer.append(nn.LeakyReLU(0.2))\n            elif config.activation == \"gelu\":\n                layer.append(nn.GELU())\n\n            if config.dropout &gt; 0:\n                layer.append(nn.Dropout(config.dropout))\n\n            self.layers.append(nn.Sequential(*layer))\n\n        # Output layer\n        self.output_layer = nn.Linear(dims[-1], config.output_dim)\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Forward pass.\"\"\"\n        batch_size, seq_len, feat_dim = x.shape\n\n        # Reshape for processing each timestep\n        x = x.reshape(-1, feat_dim)\n\n        # Apply the layers\n        for layer in self.layers:\n            x = layer(x)\n\n        # Apply the output layer\n        x = self.output_layer(x)\n\n        # Reshape back to sequence\n        x = x.reshape(batch_size, seq_len, self.config.output_dim)\n\n        return x\n</code></pre> <p>Note the <code>@ComponentRegistry.register(\"custom_encoder\")</code> decorator, which registers the component with the registry.</p>"},{"location":"tutorials/custom-components/#step-3-create-a-configuration-file","title":"Step 3: Create a Configuration File","text":"<p>Create a YAML configuration file for your component:</p> <pre><code># configs/model/event_encoder/custom.yaml\nname: custom_encoder\ntype: custom_encoder\ninput_dim: 64\nhidden_dims: [128, 64]\noutput_dim: 32\ndropout: 0.2\nuse_batch_norm: true\nactivation: gelu\n</code></pre>"},{"location":"tutorials/custom-components/#step-4-use-your-component-in-an-experiment","title":"Step 4: Use Your Component in an Experiment","text":"<p>Create an experiment configuration that uses your custom component:</p> <pre><code># configs/experiment/custom_experiment.yaml\n# @package _global_\n\ndefaults:\n  - override /model/event_encoder: custom.yaml\n  - override /model/sequence_encoder: transformer.yaml\n  - override /trainer: default.yaml\n  - override /model: default.yaml\n  - _self_\n\ntags: [\"custom\", \"transformer\"]\n\nseed: 12345\n\ntrainer:\n  max_epochs: 50\n  gradient_clip_val: 0.5\n\nmodel:\n  optimizer:\n    lr: 1.0e-4\n    weight_decay: 0.01\n</code></pre>"},{"location":"tutorials/custom-components/#step-5-import-your-component-module","title":"Step 5: Import Your Component Module","text":"<p>Make sure your component module is imported somewhere in your code. You can do this in your main training script:</p> <pre><code># src/train.py\nimport hydra\nfrom omegaconf import DictConfig\n\n# Import your custom components\nimport tabular_ssl.models.custom_components\n\n@hydra.main(config_path=\"../configs\", config_name=\"config\")\ndef main(config: DictConfig):\n    # Rest of your code...\n</code></pre>"},{"location":"tutorials/custom-components/#step-6-run-your-experiment","title":"Step 6: Run Your Experiment","text":"<p>Run your experiment with your custom component:</p> <pre><code>python src/train.py experiment=custom_experiment\n</code></pre>"},{"location":"tutorials/custom-components/#creating-other-component-types","title":"Creating Other Component Types","text":""},{"location":"tutorials/custom-components/#custom-sequence-encoder","title":"Custom Sequence Encoder","text":"<p>Here's how to create a custom sequence encoder:</p> <pre><code># Configuration\nclass CustomSequenceEncoderConfig(ComponentConfig):\n    input_dim: int = Field(..., description=\"Input dimension\")\n    hidden_dim: int = Field(..., description=\"Hidden dimension\")\n    num_layers: int = Field(1, description=\"Number of layers\")\n    dropout: float = Field(0.1, description=\"Dropout rate\")\n\n# Component\n@ComponentRegistry.register(\"custom_sequence_encoder\")\nclass CustomSequenceEncoder(SequenceEncoder):\n    def __init__(self, config: CustomSequenceEncoderConfig):\n        super().__init__(config)\n        self.config = config\n\n        # Implementation...\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        # Forward pass...\n        return x\n</code></pre>"},{"location":"tutorials/custom-components/#custom-projection-head","title":"Custom Projection Head","text":"<p>Here's how to create a custom projection head:</p> <pre><code># Configuration\nclass CustomProjectionHeadConfig(ComponentConfig):\n    input_dim: int = Field(..., description=\"Input dimension\")\n    output_dim: int = Field(..., description=\"Output dimension\")\n\n# Component\n@ComponentRegistry.register(\"custom_projection_head\")\nclass CustomProjectionHead(ProjectionHead):\n    def __init__(self, config: CustomProjectionHeadConfig):\n        super().__init__(config)\n        self.config = config\n\n        # Implementation...\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        # Forward pass...\n        return x\n</code></pre>"},{"location":"tutorials/custom-components/#advanced-component-with-custom-forward-arguments","title":"Advanced: Component with Custom Forward Arguments","text":"<p>You can create components with custom forward arguments:</p> <pre><code>@ComponentRegistry.register(\"custom_encoder_with_mask\")\nclass CustomEncoderWithMask(EventEncoder):\n    def __init__(self, config: CustomEncoderConfig):\n        super().__init__(config)\n        # Implementation...\n\n    def forward(self, x: torch.Tensor, mask: Optional[torch.Tensor] = None) -&gt; torch.Tensor:\n        \"\"\"Forward pass with optional mask.\"\"\"\n        # Implementation using mask...\n        return x\n</code></pre>"},{"location":"tutorials/custom-components/#advanced-component-with-multiple-output-values","title":"Advanced: Component with Multiple Output Values","text":"<p>Components can return multiple values:</p> <pre><code>@ComponentRegistry.register(\"custom_encoder_with_attention\")\nclass CustomEncoderWithAttention(EventEncoder):\n    def __init__(self, config: CustomEncoderConfig):\n        super().__init__(config)\n        # Implementation...\n\n    def forward(self, x: torch.Tensor) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Forward pass returning encoded values and attention weights.\"\"\"\n        # Implementation...\n        return encoded, attention_weights\n</code></pre>"},{"location":"tutorials/custom-components/#advanced-component-with-custom-methods","title":"Advanced: Component with Custom Methods","text":"<p>Components can have custom methods beyond the standard <code>forward</code>:</p> <pre><code>@ComponentRegistry.register(\"custom_autoencoder\")\nclass CustomAutoEncoder(EventEncoder):\n    def __init__(self, config: CustomEncoderConfig):\n        super().__init__(config)\n        # Implementation...\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Forward pass (encoding only).\"\"\"\n        # Implementation...\n        return encoded\n\n    def decode(self, z: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Decode latent representation.\"\"\"\n        # Implementation...\n        return decoded\n\n    def reconstruct(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Full reconstruction.\"\"\"\n        z = self.forward(x)\n        return self.decode(z)\n</code></pre>"},{"location":"tutorials/custom-components/#conclusion","title":"Conclusion","text":"<p>You've learned how to create and use custom components in Tabular SSL. The component registry pattern allows you to extend the library with your own implementations while maintaining type safety and configuration validation.</p> <p>By creating custom components, you can: - Implement new architectures - Add domain-specific functionality - Experiment with novel approaches - Create specialized components for specific datasets</p> <p>Remember to always provide proper documentation for your components and to follow the library's design patterns for consistency. </p>"},{"location":"tutorials/getting-started/","title":"Getting Started with Tabular SSL","text":"<p>This tutorial will guide you through the process of setting up and using the Tabular SSL library for self-supervised learning on tabular data.</p>"},{"location":"tutorials/getting-started/#installation","title":"Installation","text":"<p>First, install the library using pip:</p> <pre><code>pip install tabular-ssl\n</code></pre>"},{"location":"tutorials/getting-started/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of how to use Tabular SSL:</p> <pre><code>import pandas as pd\nfrom tabular_ssl import TabularSSL\nfrom tabular_ssl.data import DataLoader\n\n# Load your data\ndata_loader = DataLoader()\ndata = data_loader.load_data('your_data.csv')\n\n# Initialize the model\nmodel = TabularSSL(\n    input_dim=data.shape[1],\n    hidden_dim=256,\n    num_layers=4,\n    num_heads=4\n)\n\n# Train the model\nhistory = model.train(\n    data=data,\n    batch_size=32,\n    epochs=100,\n    learning_rate=1e-4\n)\n\n# Make predictions\npredictions = model.predict(new_data)\n</code></pre>"},{"location":"tutorials/getting-started/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"tutorials/getting-started/#1-data-preparation","title":"1. Data Preparation","text":"<p>First, prepare your data:</p> <pre><code># Load and preprocess your data\ndata_loader = DataLoader()\ndata = data_loader.load_data('your_data.csv')\n\n# If you have categorical columns, specify them\ncategorical_cols = ['category1', 'category2']\ndata = data_loader.preprocess(data, categorical_cols=categorical_cols)\n</code></pre>"},{"location":"tutorials/getting-started/#2-model-configuration","title":"2. Model Configuration","text":"<p>Configure your model with appropriate parameters:</p> <pre><code>model = TabularSSL(\n    input_dim=data.shape[1],  # Number of features\n    hidden_dim=256,           # Hidden layer dimension\n    num_layers=4,             # Number of transformer layers\n    num_heads=4,              # Number of attention heads\n    dropout=0.1,              # Dropout rate\n    mask_ratio=0.15           # Feature masking ratio\n)\n</code></pre>"},{"location":"tutorials/getting-started/#3-training","title":"3. Training","text":"<p>Train the model using self-supervised learning:</p> <pre><code>history = model.train(\n    data=data,\n    batch_size=32,\n    epochs=100,\n    learning_rate=1e-4\n)\n</code></pre>"},{"location":"tutorials/getting-started/#4-evaluation","title":"4. Evaluation","text":"<p>Evaluate your model's performance:</p> <pre><code>from tabular_ssl.utils import evaluate_model, plot_training_history\n\n# Plot training history\nplot_training_history(history)\n\n# Evaluate model performance\nmetrics = evaluate_model(model, test_data, metrics=['accuracy', 'f1'])\nprint(metrics)\n</code></pre>"},{"location":"tutorials/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Basic Usage tutorial for more advanced examples</li> <li>Explore the API Reference for detailed documentation</li> <li>Learn about different SSL Methods you can use</li> </ul>"},{"location":"tutorials/getting-started/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorials/getting-started/#memory-issues","title":"Memory Issues","text":"<p>If you encounter memory issues with large datasets:</p> <pre><code># Use a smaller batch size\nmodel.train(data, batch_size=16)\n\n# Or reduce model complexity\nmodel = TabularSSL(\n    input_dim=data.shape[1],\n    hidden_dim=128,  # Reduced from 256\n    num_layers=2,    # Reduced from 4\n    num_heads=2      # Reduced from 4\n)\n</code></pre>"},{"location":"tutorials/getting-started/#training-stability","title":"Training Stability","text":"<p>For better training stability:</p> <pre><code># Use a lower learning rate\nmodel.train(data, learning_rate=1e-5)\n\n# Increase the number of epochs\nmodel.train(data, epochs=200)\n</code></pre>"},{"location":"tutorials/getting-started/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guide </li> </ul>"}]}